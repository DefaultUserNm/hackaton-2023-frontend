{"ast":null,"code":"/*\r\n* Treant-js\r\n*\r\n* (c) 2013 Fran Peručić\r\n* Treant-js may be freely distributed under the MIT license.\r\n* For all details and documentation:\r\n* http://fperucic.github.io/treant-js\r\n*\r\n* Treant is an open-source JavaScipt library for visualization of tree diagrams.\r\n* It implements the node positioning algorithm of John Q. Walker II \"Positioning nodes for General Trees\".\r\n*\r\n* References:\r\n* Emilio Cortegoso Lobato: ECOTree.js v1.0 (October 26th, 2006)\r\n*\r\n*/\n\n;\n(function (exports) {\n  var UTIL = {\n    inheritAttrs: function (me, from) {\n      for (var attr in from) {\n        if (typeof from[attr] !== 'function') {\n          if (me[attr] instanceof Object && from[attr] instanceof Object) {\n            this.inheritAttrs(me[attr], from[attr]);\n          } else {\n            me[attr] = from[attr];\n          }\n        }\n      }\n    },\n    createMerge: function (obj1, obj2) {\n      var newObj = {};\n      if (obj1) this.inheritAttrs(newObj, this.cloneObj(obj1));\n      if (obj2) this.inheritAttrs(newObj, obj2);\n      return newObj;\n    },\n    cloneObj: function (obj) {\n      if (Object(obj) !== obj) {\n        return obj;\n      }\n      var res = new obj.constructor();\n      for (var key in obj) if (obj[\"hasOwnProperty\"](key)) {\n        res[key] = this.cloneObj(obj[key]);\n      }\n      return res;\n    },\n    addEvent: function (el, eventType, handler) {\n      if (el.addEventListener) {\n        // DOM Level 2 browsers\n        el.addEventListener(eventType, handler, false);\n      } else if (el.attachEvent) {\n        // IE <= 8\n        el.attachEvent('on' + eventType, handler);\n      } else {\n        // ancient browsers\n        el['on' + eventType] = handler;\n      }\n    },\n    hasClass: function (element, my_class) {\n      return (\" \" + element.className + \" \").replace(/[\\n\\t]/g, \" \").indexOf(\" \" + my_class + \" \") > -1;\n    }\n  };\n\n  /**\r\n  * ImageLoader constructor.\r\n  * ImageLoader is used for determening if all the images from the Tree are loaded.\r\n  * \tNode size (width, height) can be correcty determined only when all inner images are loaded\r\n  */\n  var ImageLoader = function () {\n    this.loading = [];\n  };\n  ImageLoader.prototype = {\n    processNode: function (node) {\n      var images = node.nodeDOM.getElementsByTagName('img'),\n        i = images.length;\n      while (i--) {\n        this.create(node, images[i]);\n      }\n    },\n    removeAll: function (img_src) {\n      var i = this.loading.length;\n      while (i--) {\n        if (this.loading[i] === img_src) {\n          this.loading.splice(i, 1);\n        }\n      }\n    },\n    create: function (node, image) {\n      var self = this,\n        source = image.src;\n      this.loading.push(source);\n      function imgTrigger() {\n        self.removeAll(source);\n        node.width = node.nodeDOM.offsetWidth;\n        node.height = node.nodeDOM.offsetHeight;\n      }\n      if (image.complete) {\n        return imgTrigger();\n      }\n      UTIL.addEvent(image, 'load', imgTrigger);\n      UTIL.addEvent(image, 'error', imgTrigger); // handle broken url-s\n\n      // load event is not fired for cached images, force the load event\n      image.src += \"?\" + new Date().getTime();\n    },\n    isNotLoading: function () {\n      return this.loading.length === 0;\n    }\n  };\n\n  /**\r\n  * Class: TreeStore\r\n  * TreeStore is used for holding initialized Tree objects\r\n  * \tIts purpose is to avoid global variables and enable multiple Trees on the page.\r\n  */\n\n  var TreeStore = {\n    store: [],\n    createTree: function (jsonConfig) {\n      this.store.push(new Tree(jsonConfig, this.store.length));\n      return this.store[this.store.length - 1]; // return newly created tree\n    },\n\n    get: function (treeId) {\n      return this.store[treeId];\n    },\n    destroy: function (tree_id) {\n      var tree = this.get(tree_id);\n      if (tree) {\n        tree._R.remove();\n        var draw_area = tree.drawArea;\n        while (draw_area.firstChild) {\n          draw_area.removeChild(draw_area.firstChild);\n        }\n        var classes = draw_area.className.split(' '),\n          classes_to_stay = [];\n        for (var i = 0; i < classes.length; i++) {\n          var cls = classes[i];\n          if (cls != 'Treant' && cls != 'Treant-loaded') {\n            classes_to_stay.push(cls);\n          }\n        }\n        ;\n        draw_area.style.overflowY = '';\n        draw_area.style.overflowX = '';\n        draw_area.className = classes_to_stay.join(' ');\n        this.store[tree_id] = null;\n      }\n    }\n  };\n\n  /**\r\n  * Tree constructor.\r\n  */\n  var Tree = function (jsonConfig, treeId) {\n    this.id = treeId;\n    this.imageLoader = new ImageLoader();\n    this.CONFIG = UTIL.createMerge(Tree.CONFIG, jsonConfig.chart);\n    this.drawArea = document.getElementById(this.CONFIG.container.substring(1));\n    this.drawArea.className += \" Treant\";\n    this.nodeDB = new NodeDB(jsonConfig.nodeStructure, this);\n\n    // key store for storing reference to node connectors,\n    // key = nodeId where the connector ends\n    this.connectionStore = {};\n  };\n  Tree.prototype = {\n    positionTree: function (callback) {\n      var self = this;\n      if (this.imageLoader.isNotLoading()) {\n        var root = this.root(),\n          orient = this.CONFIG.rootOrientation;\n        this.resetLevelData();\n        this.firstWalk(root, 0);\n        this.secondWalk(root, 0, 0, 0);\n        this.positionNodes();\n        if (this.CONFIG.animateOnInit) {\n          setTimeout(function () {\n            root.toggleCollapse();\n          }, this.CONFIG.animateOnInitDelay);\n        }\n        if (!this.loaded) {\n          this.drawArea.className += \" Treant-loaded\"; // nodes are hidden until .loaded class is add\n          if (Object.prototype.toString.call(callback) === \"[object Function]\") {\n            callback(self);\n          }\n          this.loaded = true;\n        }\n      } else {\n        setTimeout(function () {\n          self.positionTree(callback);\n        }, 10);\n      }\n    },\n    /*\r\n    * In a first post-order walk, every node of the tree is\r\n    * assigned a preliminary x-coordinate (held in field\r\n    * node->flPrelim). In addition, internal nodes are\r\n    * given modifiers, which will be used to move their\r\n    * children to the right (held in field\r\n    * node->flModifier).\r\n    */\n    firstWalk: function (node, level) {\n      node.prelim = null;\n      node.modifier = null;\n      this.setNeighbors(node, level);\n      this.calcLevelDim(node, level);\n      var leftSibling = node.leftSibling();\n      if (node.childrenCount() === 0 || level == this.CONFIG.maxDepth) {\n        // set preliminary x-coordinate\n        if (leftSibling) {\n          node.prelim = leftSibling.prelim + leftSibling.size() + this.CONFIG.siblingSeparation;\n        } else {\n          node.prelim = 0;\n        }\n      } else {\n        //node is not a leaf,  firstWalk for each child\n        for (var i = 0, n = node.childrenCount(); i < n; i++) {\n          this.firstWalk(node.childAt(i), level + 1);\n        }\n        var midPoint = node.childrenCenter() - node.size() / 2;\n        if (leftSibling) {\n          node.prelim = leftSibling.prelim + leftSibling.size() + this.CONFIG.siblingSeparation;\n          node.modifier = node.prelim - midPoint;\n          this.apportion(node, level);\n        } else {\n          node.prelim = midPoint;\n        }\n\n        // handle stacked children positioning\n        if (node.stackParent) {\n          // hadle the parent of stacked children\n          node.modifier += this.nodeDB.get(node.stackChildren[0]).size() / 2 + node.connStyle.stackIndent;\n        } else if (node.stackParentId) {\n          // handle stacked children\n          node.prelim = 0;\n        }\n      }\n    },\n    /*\r\n    * Clean up the positioning of small sibling subtrees.\r\n    * Subtrees of a node are formed independently and\r\n    * placed as close together as possible. By requiring\r\n    * that the subtrees be rigid at the time they are put\r\n    * together, we avoid the undesirable effects that can\r\n    * accrue from positioning nodes rather than subtrees.\r\n    */\n    apportion: function (node, level) {\n      var firstChild = node.firstChild(),\n        firstChildLeftNeighbor = firstChild.leftNeighbor(),\n        compareDepth = 1,\n        depthToStop = this.CONFIG.maxDepth - level;\n      while (firstChild && firstChildLeftNeighbor && compareDepth <= depthToStop) {\n        // calculate the position of the firstChild, according to the position of firstChildLeftNeighbor\n\n        var modifierSumRight = 0,\n          modifierSumLeft = 0,\n          leftAncestor = firstChildLeftNeighbor,\n          rightAncestor = firstChild;\n        for (var i = 0; i < compareDepth; i++) {\n          leftAncestor = leftAncestor.parent();\n          rightAncestor = rightAncestor.parent();\n          modifierSumLeft += leftAncestor.modifier;\n          modifierSumRight += rightAncestor.modifier;\n          // all the stacked children are oriented towards right so use right variables\n          if (rightAncestor.stackParent !== undefined) modifierSumRight += rightAncestor.size() / 2;\n        }\n\n        // find the gap between two trees and apply it to subTrees\n        // and mathing smaller gaps to smaller subtrees\n\n        var totalGap = firstChildLeftNeighbor.prelim + modifierSumLeft + firstChildLeftNeighbor.size() + this.CONFIG.subTeeSeparation - (firstChild.prelim + modifierSumRight);\n        if (totalGap > 0) {\n          var subtreeAux = node,\n            numSubtrees = 0;\n\n          // count all the subtrees in the LeftSibling\n          while (subtreeAux && subtreeAux.id != leftAncestor.id) {\n            subtreeAux = subtreeAux.leftSibling();\n            numSubtrees++;\n          }\n          if (subtreeAux) {\n            var subtreeMoveAux = node,\n              singleGap = totalGap / numSubtrees;\n            while (subtreeMoveAux.id != leftAncestor.id) {\n              subtreeMoveAux.prelim += totalGap;\n              subtreeMoveAux.modifier += totalGap;\n              totalGap -= singleGap;\n              subtreeMoveAux = subtreeMoveAux.leftSibling();\n            }\n          }\n        }\n        compareDepth++;\n        if (firstChild.childrenCount() === 0) {\n          firstChild = node.leftMost(0, compareDepth);\n        } else {\n          firstChild = firstChild.firstChild();\n        }\n        if (firstChild) {\n          firstChildLeftNeighbor = firstChild.leftNeighbor();\n        }\n      }\n    },\n    /*\r\n    * During a second pre-order walk, each node is given a\r\n       * final x-coordinate by summing its preliminary\r\n       * x-coordinate and the modifiers of all the node's\r\n       * ancestors.  The y-coordinate depends on the height of\r\n       * the tree.  (The roles of x and y are reversed for\r\n       * RootOrientations of EAST or WEST.)\r\n    */\n    secondWalk: function (node, level, X, Y) {\n      if (level <= this.CONFIG.maxDepth) {\n        var xTmp = node.prelim + X,\n          yTmp = Y,\n          align = this.CONFIG.nodeAlign,\n          orinet = this.CONFIG.rootOrientation,\n          levelHeight,\n          nodesizeTmp;\n        if (orinet == 'NORTH' || orinet == 'SOUTH') {\n          levelHeight = this.levelMaxDim[level].height;\n          nodesizeTmp = node.height;\n          if (node.pseudo) node.height = levelHeight; // assign a new size to pseudo nodes\n        } else if (orinet == 'WEST' || orinet == 'EAST') {\n          levelHeight = this.levelMaxDim[level].width;\n          nodesizeTmp = node.width;\n          if (node.pseudo) node.width = levelHeight; // assign a new size to pseudo nodes\n        }\n\n        node.X = xTmp;\n        if (node.pseudo) {\n          // pseudo nodes need to be properly aligned, otherwise position is not correct in some examples\n          if (orinet == 'NORTH' || orinet == 'WEST') {\n            node.Y = yTmp; // align \"BOTTOM\"\n          } else if (orinet == 'SOUTH' || orinet == 'EAST') {\n            node.Y = yTmp + (levelHeight - nodesizeTmp); // align \"TOP\"\n          }\n        } else {\n          node.Y = align == 'CENTER' ? yTmp + (levelHeight - nodesizeTmp) / 2 : align == 'TOP' ? yTmp + (levelHeight - nodesizeTmp) : yTmp;\n        }\n        if (orinet == 'WEST' || orinet == 'EAST') {\n          var swapTmp = node.X;\n          node.X = node.Y;\n          node.Y = swapTmp;\n        }\n        if (orinet == 'SOUTH') {\n          node.Y = -node.Y - nodesizeTmp;\n        } else if (orinet == 'EAST') {\n          node.X = -node.X - nodesizeTmp;\n        }\n        if (node.childrenCount() !== 0) {\n          if (node.id === 0 && this.CONFIG.hideRootNode) {\n            // ako je root node Hiden onda nemoj njegovu dijecu pomaknut po Y osi za Level separation, neka ona budu na vrhu\n            this.secondWalk(node.firstChild(), level + 1, X + node.modifier, Y);\n          } else {\n            this.secondWalk(node.firstChild(), level + 1, X + node.modifier, Y + levelHeight + this.CONFIG.levelSeparation);\n          }\n        }\n        if (node.rightSibling()) {\n          this.secondWalk(node.rightSibling(), level, X, Y);\n        }\n      }\n    },\n    // position all the nodes, center the tree in center of its container\n    // 0,0 coordinate is in the upper left corner\n    positionNodes: function () {\n      var self = this,\n        treeSize = {\n          x: self.nodeDB.getMinMaxCoord('X', null, null),\n          y: self.nodeDB.getMinMaxCoord('Y', null, null)\n        },\n        treeWidth = treeSize.x.max - treeSize.x.min,\n        treeHeight = treeSize.y.max - treeSize.y.min,\n        treeCenter = {\n          x: treeSize.x.max - treeWidth / 2,\n          y: treeSize.y.max - treeHeight / 2\n        },\n        containerCenter = {\n          x: self.drawArea.clientWidth / 2,\n          y: self.drawArea.clientHeight / 2\n        },\n        deltaX = containerCenter.x - treeCenter.x,\n        deltaY = containerCenter.y - treeCenter.y,\n        // all nodes must have positive X or Y coordinates, handle this with offsets\n        negOffsetX = treeSize.x.min + deltaX <= 0 ? Math.abs(treeSize.x.min) : 0,\n        negOffsetY = treeSize.y.min + deltaY <= 0 ? Math.abs(treeSize.y.min) : 0,\n        i,\n        len,\n        node;\n      this.handleOverflow(treeWidth, treeHeight);\n\n      // position all the nodes\n      for (i = 0, len = this.nodeDB.db.length; i < len; i++) {\n        node = this.nodeDB.get(i);\n        if (node.id === 0 && this.CONFIG.hideRootNode) continue;\n\n        // if the tree is smaller than the draw area, then center the tree within drawing area\n        node.X += negOffsetX + (treeWidth < this.drawArea.clientWidth ? deltaX : this.CONFIG.padding);\n        node.Y += negOffsetY + (treeHeight < this.drawArea.clientHeight ? deltaY : this.CONFIG.padding);\n        var collapsedParent = node.collapsedParent(),\n          hidePoint = null;\n        if (collapsedParent) {\n          // position the node behind the connector point of the parent, so future animations can be visible\n          hidePoint = collapsedParent.connectorPoint(true);\n          node.hide(hidePoint);\n        } else if (node.positioned) {\n          // node is allready positioned,\n          node.show();\n        } else {\n          // inicijalno stvaranje nodeova, postavi lokaciju\n          node.nodeDOM.style.left = node.X + 'px';\n          node.nodeDOM.style.top = node.Y + 'px';\n          node.positioned = true;\n        }\n        if (node.id !== 0 && !(node.parent().id === 0 && this.CONFIG.hideRootNode)) {\n          this.setConnectionToParent(node, hidePoint); // skip the root node\n        } else if (!this.CONFIG.hideRootNode && node.drawLineThrough) {\n          // drawlinethrough is performed for for the root node also\n          node.drawLineThroughMe();\n        }\n      }\n    },\n    // create Raphael instance, set scrollbars if necessary\n    handleOverflow: function (treeWidth, treeHeight) {\n      var viewWidth = treeWidth < this.drawArea.clientWidth ? this.drawArea.clientWidth : treeWidth + this.CONFIG.padding * 2,\n        viewHeight = treeHeight < this.drawArea.clientHeight ? this.drawArea.clientHeight : treeHeight + this.CONFIG.padding * 2;\n      if (this._R) {\n        this._R.setSize(viewWidth, viewHeight);\n      } else {\n        this._R = Raphael(this.drawArea, viewWidth, viewHeight);\n      }\n      if (this.CONFIG.scrollbar == 'native') {\n        if (this.drawArea.clientWidth < treeWidth) {\n          // is owerflow-x necessary\n          this.drawArea.style.overflowX = \"auto\";\n        }\n        if (this.drawArea.clientHeight < treeHeight) {\n          // is owerflow-y necessary\n          this.drawArea.style.overflowY = \"auto\";\n        }\n      } else if (this.CONFIG.scrollbar == 'fancy') {\n        var jq_drawArea = $(this.drawArea);\n        if (jq_drawArea.hasClass('ps-container')) {\n          // znaci da je 'fancy' vec inicijaliziran, treba updateat\n\n          jq_drawArea.find('.Treant').css({\n            width: viewWidth,\n            height: viewHeight\n          });\n          jq_drawArea.perfectScrollbar('update');\n        } else {\n          var mainContiner = jq_drawArea.wrapInner('<div class=\"Treant\"/>'),\n            child = mainContiner.find('.Treant');\n          child.css({\n            width: viewWidth,\n            height: viewHeight\n          });\n          mainContiner.perfectScrollbar();\n        }\n      } // else this.CONFIG.scrollbar == 'None'\n    },\n\n    setConnectionToParent: function (node, hidePoint) {\n      var stacked = node.stackParentId,\n        connLine,\n        parent = stacked ? this.nodeDB.get(stacked) : node.parent(),\n        pathString = hidePoint ? this.getPointPathString(hidePoint) : this.getPathString(parent, node, stacked);\n      if (this.connectionStore[node.id]) {\n        // connector allready exists, update the connector geometry\n        connLine = this.connectionStore[node.id];\n        this.animatePath(connLine, pathString);\n      } else {\n        connLine = this._R.path(pathString);\n        this.connectionStore[node.id] = connLine;\n\n        // don't show connector arrows por pseudo nodes\n        if (node.pseudo) {\n          delete parent.connStyle.style['arrow-end'];\n        }\n        if (parent.pseudo) {\n          delete parent.connStyle.style['arrow-start'];\n        }\n        connLine.attr(parent.connStyle.style);\n        if (node.drawLineThrough || node.pseudo) {\n          node.drawLineThroughMe(hidePoint);\n        }\n      }\n    },\n    // create the path which is represanted as a point, used for hiding the connection\n    getPointPathString: function (hp) {\n      // \"_\" indicates the path will be hidden\n      return [\"_M\", hp.x, \",\", hp.y, 'L', hp.x, \",\", hp.y, hp.x, \",\", hp.y].join(\" \");\n    },\n    animatePath: function (path, pathString) {\n      if (path.hidden && pathString.charAt(0) !== \"_\") {\n        // path will be shown, so show it\n        path.show();\n        path.hidden = false;\n      }\n      path.animate({\n        path: pathString.charAt(0) === \"_\" ? pathString.substring(1) : pathString // remove the \"_\" prefix if it exists\n      }, this.CONFIG.animation.connectorsSpeed, this.CONFIG.animation.connectorsAnimation, function () {\n        if (pathString.charAt(0) === \"_\") {\n          // animation is hiding the path, hide it at the and of animation\n          path.hide();\n          path.hidden = true;\n        }\n      });\n    },\n    getPathString: function (from_node, to_node, stacked) {\n      var startPoint = from_node.connectorPoint(true),\n        endPoint = to_node.connectorPoint(false),\n        orinet = this.CONFIG.rootOrientation,\n        connType = from_node.connStyle.type,\n        P1 = {},\n        P2 = {};\n      if (orinet == 'NORTH' || orinet == 'SOUTH') {\n        P1.y = P2.y = (startPoint.y + endPoint.y) / 2;\n        P1.x = startPoint.x;\n        P2.x = endPoint.x;\n      } else if (orinet == 'EAST' || orinet == 'WEST') {\n        P1.x = P2.x = (startPoint.x + endPoint.x) / 2;\n        P1.y = startPoint.y;\n        P2.y = endPoint.y;\n      }\n\n      // sp, p1, pm, p2, ep == \"x,y\"\n      var sp = startPoint.x + ',' + startPoint.y,\n        p1 = P1.x + ',' + P1.y,\n        p2 = P2.x + ',' + P2.y,\n        ep = endPoint.x + ',' + endPoint.y,\n        pm = (P1.x + P2.x) / 2 + ',' + (P1.y + P2.y) / 2,\n        pathString,\n        stackPoint;\n      if (stacked) {\n        // STACKED CHILDREN\n\n        stackPoint = orinet == 'EAST' || orinet == 'WEST' ? endPoint.x + ',' + startPoint.y : startPoint.x + ',' + endPoint.y;\n        if (connType == \"step\" || connType == \"straight\") {\n          pathString = [\"M\", sp, 'L', stackPoint, 'L', ep];\n        } else if (connType == \"curve\" || connType == \"bCurve\") {\n          var helpPoint,\n            // used for nicer curve lines\n            indent = from_node.connStyle.stackIndent;\n          if (orinet == 'NORTH') {\n            helpPoint = endPoint.x - indent + ',' + (endPoint.y - indent);\n          } else if (orinet == 'SOUTH') {\n            helpPoint = endPoint.x - indent + ',' + (endPoint.y + indent);\n          } else if (orinet == 'EAST') {\n            helpPoint = endPoint.x + indent + ',' + startPoint.y;\n          } else if (orinet == 'WEST') {\n            helpPoint = endPoint.x - indent + ',' + startPoint.y;\n          }\n          pathString = [\"M\", sp, 'L', helpPoint, 'S', stackPoint, ep];\n        }\n      } else {\n        // NORAML CHILDREN\n\n        if (connType == \"step\") {\n          pathString = [\"M\", sp, 'L', p1, 'L', p2, 'L', ep];\n        } else if (connType == \"curve\") {\n          pathString = [\"M\", sp, 'C', p1, p2, ep];\n        } else if (connType == \"bCurve\") {\n          pathString = [\"M\", sp, 'Q', p1, pm, 'T', ep];\n        } else if (connType == \"straight\") {\n          pathString = [\"M\", sp, 'L', sp, ep];\n        }\n      }\n      return pathString.join(\" \");\n    },\n    // algorithm works from left to right, so previous processed node will be left neigbor of the next node\n    setNeighbors: function (node, level) {\n      node.leftNeighborId = this.lastNodeOnLevel[level];\n      if (node.leftNeighborId) node.leftNeighbor().rightNeighborId = node.id;\n      this.lastNodeOnLevel[level] = node.id;\n    },\n    // used for calculation of height and width of a level (level dimensions)\n    calcLevelDim: function (node, level) {\n      // root node is on level 0\n      if (this.levelMaxDim[level]) {\n        if (this.levelMaxDim[level].width < node.width) this.levelMaxDim[level].width = node.width;\n        if (this.levelMaxDim[level].height < node.height) this.levelMaxDim[level].height = node.height;\n      } else {\n        this.levelMaxDim[level] = {\n          width: node.width,\n          height: node.height\n        };\n      }\n    },\n    resetLevelData: function () {\n      this.lastNodeOnLevel = [];\n      this.levelMaxDim = [];\n    },\n    root: function () {\n      return this.nodeDB.get(0);\n    }\n  };\n\n  /**\r\n  * NodeDB constructor.\r\n  * NodeDB is used for storing the nodes. Each tree has its own NodeDB.\r\n  */\n  var NodeDB = function (nodeStructure, tree) {\n    this.db = [];\n    var self = this;\n    function itterateChildren(node, parentId) {\n      var newNode = self.createNode(node, parentId, tree, null);\n      if (node.children) {\n        newNode.children = [];\n\n        // pseudo node is used for descending children to the next level\n        if (node.childrenDropLevel && node.childrenDropLevel > 0) {\n          while (node.childrenDropLevel--) {\n            // pseudo node needs to inherit the connection style from its parent for continuous connectors\n            var connStyle = UTIL.cloneObj(newNode.connStyle);\n            newNode = self.createNode('pseudo', newNode.id, tree, null);\n            newNode.connStyle = connStyle;\n            newNode.children = [];\n          }\n        }\n        var stack = node.stackChildren && !self.hasGrandChildren(node) ? newNode.id : null;\n\n        // svildren are position on separate leves, one beneeth the other\n        if (stack !== null) {\n          newNode.stackChildren = [];\n        }\n        for (var i = 0, len = node.children.length; i < len; i++) {\n          if (stack !== null) {\n            newNode = self.createNode(node.children[i], newNode.id, tree, stack);\n            if (i + 1 < len) newNode.children = []; // last node cant have children\n          } else {\n            itterateChildren(node.children[i], newNode.id);\n          }\n        }\n      }\n    }\n    if (tree.CONFIG.animateOnInit) nodeStructure.collapsed = true;\n    itterateChildren(nodeStructure, -1); // root node\n\n    this.createGeometries(tree);\n  };\n  NodeDB.prototype = {\n    createGeometries: function (tree) {\n      var i = this.db.length,\n        node;\n      while (i--) {\n        this.get(i).createGeometry(tree);\n      }\n    },\n    get: function (nodeId) {\n      return this.db[nodeId]; // get node by ID\n    },\n\n    createNode: function (nodeStructure, parentId, tree, stackParentId) {\n      var node = new TreeNode(nodeStructure, this.db.length, parentId, tree, stackParentId);\n      this.db.push(node);\n      if (parentId >= 0) this.get(parentId).children.push(node.id); //skip root node\n\n      if (stackParentId) {\n        this.get(stackParentId).stackParent = true;\n        this.get(stackParentId).stackChildren.push(node.id);\n      }\n      return node;\n    },\n    getMinMaxCoord: function (dim, parent, MinMax) {\n      // used for getting the dimensions of the tree, dim = 'X' || 'Y'\n      // looks for min and max (X and Y) within the set of nodes\n      var parent = parent || this.get(0),\n        i = parent.childrenCount(),\n        MinMax = MinMax || {\n          // start with root node dimensions\n          min: parent[dim],\n          max: parent[dim] + (dim == 'X' ? parent.width : parent.height)\n        };\n      while (i--) {\n        var node = parent.childAt(i),\n          maxTest = node[dim] + (dim == 'X' ? node.width : node.height),\n          minTest = node[dim];\n        if (maxTest > MinMax.max) {\n          MinMax.max = maxTest;\n        }\n        if (minTest < MinMax.min) {\n          MinMax.min = minTest;\n        }\n        this.getMinMaxCoord(dim, node, MinMax);\n      }\n      return MinMax;\n    },\n    hasGrandChildren: function (nodeStructure) {\n      var i = nodeStructure.children.length;\n      while (i--) {\n        if (nodeStructure.children[i].children) return true;\n      }\n    }\n  };\n\n  /**\r\n  * TreeNode constructor.\r\n  * @constructor\r\n  */\n  var TreeNode = function (nodeStructure, id, parentId, tree, stackParentId) {\n    this.id = id;\n    this.parentId = parentId;\n    this.treeId = tree.id;\n    this.prelim = 0;\n    this.modifier = 0;\n    this.stackParentId = stackParentId;\n\n    // pseudo node is a node with width=height=0, it is invisible, but necessary for the correct positiong of the tree\n    this.pseudo = nodeStructure === 'pseudo' || nodeStructure['pseudo'];\n    this.image = nodeStructure.image;\n    this.link = UTIL.createMerge(tree.CONFIG.node.link, nodeStructure.link);\n    this.connStyle = UTIL.createMerge(tree.CONFIG.connectors, nodeStructure.connectors);\n    this.drawLineThrough = nodeStructure.drawLineThrough === false ? false : nodeStructure.drawLineThrough || tree.CONFIG.node.drawLineThrough;\n    this.collapsable = nodeStructure.collapsable === false ? false : nodeStructure.collapsable || tree.CONFIG.node.collapsable;\n    this.collapsed = nodeStructure.collapsed;\n    this.text = nodeStructure.text;\n\n    // '.node' DIV\n    this.nodeInnerHTML = nodeStructure.innerHTML;\n    this.nodeHTMLclass = (tree.CONFIG.node.HTMLclass ? tree.CONFIG.node.HTMLclass : '') + (\n    // globaly defined class for the nodex\n    nodeStructure.HTMLclass ? ' ' + nodeStructure.HTMLclass : ''); // + specific node class\n\n    this.nodeHTMLid = nodeStructure.HTMLid;\n  };\n  TreeNode.prototype = {\n    Tree: function () {\n      return TreeStore.get(this.treeId);\n    },\n    dbGet: function (nodeId) {\n      return this.Tree().nodeDB.get(nodeId);\n    },\n    size: function () {\n      // returns the width of the node\n      var orient = this.Tree().CONFIG.rootOrientation;\n      if (this.pseudo) return -this.Tree().CONFIG.subTeeSeparation; // prevents of separateing the subtrees\n\n      if (orient == 'NORTH' || orient == 'SOUTH') return this.width;else if (orient == 'WEST' || orient == 'EAST') return this.height;\n    },\n    childrenCount: function () {\n      return this.collapsed || !this.children ? 0 : this.children.length;\n    },\n    childAt: function (i) {\n      return this.dbGet(this.children[i]);\n    },\n    firstChild: function () {\n      return this.childAt(0);\n    },\n    lastChild: function () {\n      return this.childAt(this.children.length - 1);\n    },\n    parent: function () {\n      return this.dbGet(this.parentId);\n    },\n    leftNeighbor: function () {\n      if (this.leftNeighborId) return this.dbGet(this.leftNeighborId);\n    },\n    rightNeighbor: function () {\n      if (this.rightNeighborId) return this.dbGet(this.rightNeighborId);\n    },\n    leftSibling: function () {\n      var leftNeighbor = this.leftNeighbor();\n      if (leftNeighbor && leftNeighbor.parentId == this.parentId) return leftNeighbor;\n    },\n    rightSibling: function () {\n      var rightNeighbor = this.rightNeighbor();\n      if (rightNeighbor && rightNeighbor.parentId == this.parentId) return rightNeighbor;\n    },\n    childrenCenter: function (tree) {\n      var first = this.firstChild(),\n        last = this.lastChild();\n      return first.prelim + (last.prelim - first.prelim + last.size()) / 2;\n    },\n    // find out if one of the node ancestors is collapsed\n    collapsedParent: function () {\n      var parent = this.parent();\n      if (!parent) return false;\n      if (parent.collapsed) return parent;\n      return parent.collapsedParent();\n    },\n    leftMost: function (level, depth) {\n      // returns the leftmost child at specific level, (initaial level = 0)\n\n      if (level >= depth) return this;\n      if (this.childrenCount() === 0) return;\n      for (var i = 0, n = this.childrenCount(); i < n; i++) {\n        var leftmostDescendant = this.childAt(i).leftMost(level + 1, depth);\n        if (leftmostDescendant) return leftmostDescendant;\n      }\n    },\n    // returns start or the end point of the connector line, origin is upper-left\n    connectorPoint: function (startPoint) {\n      var orient = this.Tree().CONFIG.rootOrientation,\n        point = {};\n      if (this.stackParentId) {\n        // return different end point if node is a stacked child\n        if (orient == 'NORTH' || orient == 'SOUTH') {\n          orient = 'WEST';\n        } else if (orient == 'EAST' || orient == 'WEST') {\n          orient = 'NORTH';\n        }\n      }\n      // if pseudo, a virtual center is used\n      if (orient == 'NORTH') {\n        point.x = this.pseudo ? this.X - this.Tree().CONFIG.subTeeSeparation / 2 : this.X + this.width / 2;\n        point.y = startPoint ? this.Y + this.height : this.Y;\n      } else if (orient == 'SOUTH') {\n        point.x = this.pseudo ? this.X - this.Tree().CONFIG.subTeeSeparation / 2 : this.X + this.width / 2;\n        point.y = startPoint ? this.Y : this.Y + this.height;\n      } else if (orient == 'EAST') {\n        point.x = startPoint ? this.X : this.X + this.width;\n        point.y = this.pseudo ? this.Y - this.Tree().CONFIG.subTeeSeparation / 2 : this.Y + this.height / 2;\n      } else if (orient == 'WEST') {\n        point.x = startPoint ? this.X + this.width : this.X;\n        point.y = this.pseudo ? this.Y - this.Tree().CONFIG.subTeeSeparation / 2 : this.Y + this.height / 2;\n      }\n      return point;\n    },\n    pathStringThrough: function () {\n      // get the geometry of a path going through the node\n      var startPoint = this.connectorPoint(true),\n        endPoint = this.connectorPoint(false);\n      return [\"M\", startPoint.x + \",\" + startPoint.y, 'L', endPoint.x + \",\" + endPoint.y].join(\" \");\n    },\n    drawLineThroughMe: function (hidePoint) {\n      // hidepoint se proslijedjuje ako je node sakriven zbog collapsed\n\n      var pathString = hidePoint ? this.Tree().getPointPathString(hidePoint) : this.pathStringThrough();\n      this.lineThroughMe = this.lineThroughMe || this.Tree()._R.path(pathString);\n      var line_style = UTIL.cloneObj(this.connStyle.style);\n      delete line_style['arrow-start'];\n      delete line_style['arrow-end'];\n      this.lineThroughMe.attr(line_style);\n      if (hidePoint) {\n        this.lineThroughMe.hide();\n        this.lineThroughMe.hidden = true;\n      }\n    },\n    addSwitchEvent: function (my_switch) {\n      var self = this;\n      UTIL.addEvent(my_switch, 'click', function (e) {\n        e.preventDefault();\n        self.toggleCollapse();\n      });\n    },\n    toggleCollapse: function () {\n      var tree = this.Tree();\n      if (!tree.inAnimation) {\n        tree.inAnimation = true;\n        this.collapsed = !this.collapsed; // toglle the collapse at each click\n        if (this.collapsed) {\n          $(this.nodeDOM).addClass('collapsed');\n        } else {\n          $(this.nodeDOM).removeClass('collapsed');\n        }\n        tree.positionTree();\n        setTimeout(function () {\n          // set the flag after the animation\n          tree.inAnimation = false;\n        }, tree.CONFIG.animation.nodeSpeed > tree.CONFIG.animation.connectorsSpeed ? tree.CONFIG.animation.nodeSpeed : tree.CONFIG.animation.connectorsSpeed);\n      }\n    },\n    hide: function (collapse_to_point) {\n      this.nodeDOM.style.overflow = \"hidden\";\n      var jq_node = $(this.nodeDOM),\n        tree = this.Tree(),\n        config = tree.CONFIG,\n        new_pos = {\n          left: collapse_to_point.x,\n          top: collapse_to_point.y\n        };\n      if (!this.hidden) {\n        new_pos.width = new_pos.height = 0;\n      }\n      if (!this.startW || !this.startH) {\n        this.startW = jq_node.outerWidth();\n        this.startH = jq_node.outerHeight();\n      }\n\n      // if parent was hidden in initial configuration, position the node behind the parent without animations\n      if (!this.positioned || this.hidden) {\n        this.nodeDOM.style.visibility = 'hidden';\n        jq_node.css(new_pos);\n        this.positioned = true;\n      } else {\n        jq_node.animate(new_pos, config.animation.nodeSpeed, config.animation.nodeAnimation, function () {\n          this.style.visibility = 'hidden';\n        });\n      }\n\n      // animate the line through node if the line exists\n      if (this.lineThroughMe) {\n        var new_path = tree.getPointPathString(collapse_to_point);\n        if (this.hidden) {\n          // update without animations\n          this.lineThroughMe.attr({\n            path: new_path\n          });\n        } else {\n          // update with animations\n          tree.animatePath(this.lineThroughMe, tree.getPointPathString(collapse_to_point));\n        }\n      }\n      this.hidden = true;\n    },\n    show: function () {\n      this.nodeDOM.style.visibility = 'visible';\n      var new_pos = {\n          left: this.X,\n          top: this.Y\n        },\n        tree = this.Tree(),\n        config = tree.CONFIG;\n\n      // if the node was hidden, update width and height\n      if (this.hidden) {\n        new_pos.width = this.startW;\n        new_pos.height = this.startH;\n      }\n      $(this.nodeDOM).animate(new_pos, config.animation.nodeSpeed, config.animation.nodeAnimation, function () {\n        // $.animate applys \"overflow:hidden\" to the node, remove it to avoid visual problems\n        this.style.overflow = \"\";\n      });\n      if (this.lineThroughMe) {\n        tree.animatePath(this.lineThroughMe, this.pathStringThrough());\n      }\n      this.hidden = false;\n    }\n  };\n  TreeNode.prototype.createGeometry = function (tree) {\n    if (this.id === 0 && tree.CONFIG.hideRootNode) {\n      this.width = 0;\n      this.height = 0;\n      return;\n    }\n    var drawArea = tree.drawArea,\n      image,\n      i,\n      /////////// CREATE NODE //////////////\n      node = this.link.href ? document.createElement('a') : document.createElement('div');\n    node.className = !this.pseudo ? TreeNode.CONFIG.nodeHTMLclass : 'pseudo';\n    if (this.nodeHTMLclass && !this.pseudo) node.className += ' ' + this.nodeHTMLclass;\n    if (this.nodeHTMLid) node.id = this.nodeHTMLid;\n    if (this.link.href) {\n      node.href = this.link.href;\n      node.target = this.link.target;\n    }\n\n    /////////// CREATE innerHTML //////////////\n    if (!this.pseudo) {\n      if (!this.nodeInnerHTML) {\n        // IMAGE\n        if (this.image) {\n          image = document.createElement('img');\n          image.src = this.image;\n          node.appendChild(image);\n        }\n\n        // TEXT\n        if (this.text) {\n          for (var key in this.text) {\n            if (TreeNode.CONFIG.textClass[key]) {\n              var text = document.createElement(this.text[key].href ? 'a' : 'p');\n\n              // meke an <a> element if required\n              if (this.text[key].href) {\n                text.href = this.text[key].href;\n                if (this.text[key].target) {\n                  text.target = this.text[key].target;\n                }\n              }\n              text.className = TreeNode.CONFIG.textClass[key];\n              text.appendChild(document.createTextNode(this.text[key].val ? this.text[key].val : this.text[key] instanceof Object ? \"'val' param missing!\" : this.text[key]));\n              node.appendChild(text);\n            }\n          }\n        }\n      } else {\n        // get some element by ID and clone its structure into a node\n        if (this.nodeInnerHTML.charAt(0) === \"#\") {\n          var elem = document.getElementById(this.nodeInnerHTML.substring(1));\n          if (elem) {\n            node = elem.cloneNode(true);\n            node.id += \"-clone\";\n            node.className += \" node\";\n          } else {\n            node.innerHTML = \"<b> Wrong ID selector </b>\";\n          }\n        } else {\n          // insert your custom HTML into a node\n          node.innerHTML = this.nodeInnerHTML;\n        }\n      }\n\n      // handle collapse switch\n      if (this.collapsed || this.collapsable && this.childrenCount() && !this.stackParentId) {\n        var my_switch = document.createElement('a');\n        my_switch.className = \"collapse-switch\";\n        node.appendChild(my_switch);\n        this.addSwitchEvent(my_switch);\n        if (this.collapsed) {\n          node.className += \" collapsed\";\n        }\n      }\n    }\n\n    /////////// APPEND all //////////////\n    drawArea.appendChild(node);\n    this.width = node.offsetWidth;\n    this.height = node.offsetHeight;\n    this.nodeDOM = node;\n    tree.imageLoader.processNode(this);\n  };\n\n  // ###########################################\n  //\t\tExpose global + default CONFIG params\n  // ###########################################\n\n  Tree.CONFIG = {\n    maxDepth: 100,\n    rootOrientation: 'NORTH',\n    // NORTH || EAST || WEST || SOUTH\n    nodeAlign: 'CENTER',\n    // CENTER || TOP || BOTTOM\n    levelSeparation: 30,\n    siblingSeparation: 30,\n    subTeeSeparation: 30,\n    hideRootNode: false,\n    animateOnInit: false,\n    animateOnInitDelay: 500,\n    padding: 15,\n    // the difference is seen only when the scrollbar is shown\n    scrollbar: 'native',\n    // \"native\" || \"fancy\" || \"None\" (PS: \"fancy\" requires jquery and perfect-scrollbar)\n\n    connectors: {\n      type: 'curve',\n      // 'curve' || 'step' || 'straight' || 'bCurve'\n      style: {\n        stroke: 'black'\n      },\n      stackIndent: 15\n    },\n    node: {\n      // each node inherits this, it can all be overrifen in node config\n\n      // HTMLclass: 'node',\n      // drawLineThrough: false,\n      // collapsable: false,\n      link: {\n        target: '_self'\n      }\n    },\n    animation: {\n      // each node inherits this, it can all be overrifen in node config\n\n      nodeSpeed: 450,\n      nodeAnimation: 'linear',\n      connectorsSpeed: 450,\n      connectorsAnimation: 'linear'\n    }\n  };\n  TreeNode.CONFIG = {\n    nodeHTMLclass: 'node',\n    textClass: {\n      name: 'node-name',\n      title: 'node-title',\n      desc: 'node-desc',\n      contact: 'node-contact'\n    }\n  };\n\n  // #############################################\n  // Makes a JSON chart config out of Array config\n  // #############################################\n\n  var JSONconfig = {\n    make: function (configArray) {\n      var i = configArray.length,\n        node;\n      this.jsonStructure = {\n        chart: null,\n        nodeStructure: null\n      };\n      //fist loop: find config, find root;\n      while (i--) {\n        node = configArray[i];\n        if (node.hasOwnProperty('container')) {\n          this.jsonStructure.chart = node;\n          continue;\n        }\n        if (!node.hasOwnProperty('parent') && !node.hasOwnProperty('container')) {\n          this.jsonStructure.nodeStructure = node;\n          node.myID = this.getID();\n        }\n      }\n      this.findChildren(configArray);\n      return this.jsonStructure;\n    },\n    findChildren: function (nodes) {\n      var parents = [0]; // start witha a root node\n\n      while (parents.length) {\n        var parentId = parents.pop(),\n          parent = this.findNode(this.jsonStructure.nodeStructure, parentId),\n          i = 0,\n          len = nodes.length,\n          children = [];\n        for (; i < len; i++) {\n          var node = nodes[i];\n          if (node.parent && node.parent.myID == parentId) {\n            // skip config and root nodes\n\n            node.myID = this.getID();\n            delete node.parent;\n            children.push(node);\n            parents.push(node.myID);\n          }\n        }\n        if (children.length) {\n          parent.children = children;\n        }\n      }\n    },\n    findNode: function (node, nodeId) {\n      var childrenLen, found;\n      if (node.myID === nodeId) {\n        return node;\n      } else if (node.children) {\n        childrenLen = node.children.length;\n        while (childrenLen--) {\n          found = this.findNode(node.children[childrenLen], nodeId);\n          if (found) {\n            return found;\n          }\n        }\n      }\n    },\n    getID: function () {\n      var i = 0;\n      return function () {\n        return i++;\n      };\n    }()\n  };\n\n  /**\r\n  * Chart constructor.\r\n  */\n  var Treant = function (jsonConfig, callback) {\n    if (jsonConfig instanceof Array) {\n      jsonConfig = JSONconfig.make(jsonConfig);\n    }\n    var newTree = TreeStore.createTree(jsonConfig);\n    newTree.positionTree(callback);\n    this.tree_id = newTree.id;\n  };\n  Treant.prototype.destroy = function () {\n    TreeStore.destroy(this.tree_id);\n  };\n\n  /* expose constructor globaly */\n  exports.Treant = Treant;\n})(this.hasOwnProperty('window') ? window : module.exports);","map":{"version":3,"names":["exports","UTIL","inheritAttrs","me","from","attr","Object","createMerge","obj1","obj2","newObj","cloneObj","obj","res","constructor","key","addEvent","el","eventType","handler","addEventListener","attachEvent","hasClass","element","my_class","className","replace","indexOf","ImageLoader","loading","prototype","processNode","node","images","nodeDOM","getElementsByTagName","i","length","create","removeAll","img_src","splice","image","self","source","src","push","imgTrigger","width","offsetWidth","height","offsetHeight","complete","Date","getTime","isNotLoading","TreeStore","store","createTree","jsonConfig","Tree","get","treeId","destroy","tree_id","tree","_R","remove","draw_area","drawArea","firstChild","removeChild","classes","split","classes_to_stay","cls","style","overflowY","overflowX","join","id","imageLoader","CONFIG","chart","document","getElementById","container","substring","nodeDB","NodeDB","nodeStructure","connectionStore","positionTree","callback","root","orient","rootOrientation","resetLevelData","firstWalk","secondWalk","positionNodes","animateOnInit","setTimeout","toggleCollapse","animateOnInitDelay","loaded","toString","call","level","prelim","modifier","setNeighbors","calcLevelDim","leftSibling","childrenCount","maxDepth","size","siblingSeparation","n","childAt","midPoint","childrenCenter","apportion","stackParent","stackChildren","connStyle","stackIndent","stackParentId","firstChildLeftNeighbor","leftNeighbor","compareDepth","depthToStop","modifierSumRight","modifierSumLeft","leftAncestor","rightAncestor","parent","undefined","totalGap","subTeeSeparation","subtreeAux","numSubtrees","subtreeMoveAux","singleGap","leftMost","X","Y","xTmp","yTmp","align","nodeAlign","orinet","levelHeight","nodesizeTmp","levelMaxDim","pseudo","swapTmp","hideRootNode","levelSeparation","rightSibling","treeSize","x","getMinMaxCoord","y","treeWidth","max","min","treeHeight","treeCenter","containerCenter","clientWidth","clientHeight","deltaX","deltaY","negOffsetX","Math","abs","negOffsetY","len","handleOverflow","db","padding","collapsedParent","hidePoint","connectorPoint","hide","positioned","show","left","top","setConnectionToParent","drawLineThrough","drawLineThroughMe","viewWidth","viewHeight","setSize","Raphael","scrollbar","jq_drawArea","$","find","css","perfectScrollbar","mainContiner","wrapInner","child","stacked","connLine","pathString","getPointPathString","getPathString","animatePath","path","hp","hidden","charAt","animate","animation","connectorsSpeed","connectorsAnimation","from_node","to_node","startPoint","endPoint","connType","type","P1","P2","sp","p1","p2","ep","pm","stackPoint","helpPoint","indent","leftNeighborId","lastNodeOnLevel","rightNeighborId","itterateChildren","parentId","newNode","createNode","children","childrenDropLevel","stack","hasGrandChildren","collapsed","createGeometries","createGeometry","nodeId","TreeNode","dim","MinMax","maxTest","minTest","link","connectors","collapsable","text","nodeInnerHTML","innerHTML","nodeHTMLclass","HTMLclass","nodeHTMLid","HTMLid","dbGet","lastChild","rightNeighbor","first","last","depth","leftmostDescendant","point","pathStringThrough","lineThroughMe","line_style","addSwitchEvent","my_switch","e","preventDefault","inAnimation","addClass","removeClass","nodeSpeed","collapse_to_point","overflow","jq_node","config","new_pos","startW","startH","outerWidth","outerHeight","visibility","nodeAnimation","new_path","href","createElement","target","appendChild","textClass","createTextNode","val","elem","cloneNode","stroke","name","title","desc","contact","JSONconfig","make","configArray","jsonStructure","hasOwnProperty","myID","getID","findChildren","nodes","parents","pop","findNode","childrenLen","found","Treant","Array","newTree","window","module"],"sources":["/Users/20294784/Documents/coding/hackaton-2023-frontend/node_modules/treant-js/Treant.js"],"sourcesContent":["/*\r\n* Treant-js\r\n*\r\n* (c) 2013 Fran Peručić\r\n* Treant-js may be freely distributed under the MIT license.\r\n* For all details and documentation:\r\n* http://fperucic.github.io/treant-js\r\n*\r\n* Treant is an open-source JavaScipt library for visualization of tree diagrams.\r\n* It implements the node positioning algorithm of John Q. Walker II \"Positioning nodes for General Trees\".\r\n*\r\n* References:\r\n* Emilio Cortegoso Lobato: ECOTree.js v1.0 (October 26th, 2006)\r\n*\r\n*/\r\n\r\n;(function( exports ){\r\n\r\n\tvar UTIL = {\r\n\t\tinheritAttrs: function(me, from) {\r\n\t\t\tfor (var attr in from) {\r\n\t\t\t\tif(typeof from[attr] !== 'function') {\r\n\t\t\t\t\tif(me[attr] instanceof Object && from[attr] instanceof Object) {\r\n\t\t\t\t\t\tthis.inheritAttrs(me[attr], from[attr]);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tme[attr] = from[attr];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tcreateMerge: function(obj1, obj2) {\r\n\t\t\tvar newObj = {};\r\n\t\t\tif(obj1) this.inheritAttrs(newObj, this.cloneObj(obj1));\r\n\t\t\tif(obj2) this.inheritAttrs(newObj, obj2);\r\n\t\t\treturn newObj;\r\n\t\t},\r\n\r\n\t\tcloneObj: function (obj) {\r\n\t\t\tif (Object(obj) !== obj) {\r\n\t\t\t\treturn obj;\r\n\t\t\t}\r\n\t\t\tvar res = new obj.constructor();\r\n\t\t\tfor (var key in obj) if (obj[\"hasOwnProperty\"](key)) {\r\n\t\t\t\tres[key] = this.cloneObj(obj[key]);\r\n\t\t\t}\r\n\t\t\treturn res;\r\n\t\t},\r\n\t\taddEvent: function(el, eventType, handler) {\r\n\t\t\tif (el.addEventListener) { // DOM Level 2 browsers\r\n\t\t\t\tel.addEventListener(eventType, handler, false);\r\n\t\t\t} else if (el.attachEvent) { // IE <= 8\r\n\t\t\t\tel.attachEvent('on' + eventType, handler);\r\n\t\t\t} else { // ancient browsers\r\n\t\t\t\tel['on' + eventType] = handler;\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\thasClass: function(element, my_class) {\r\n\t\t\treturn (\" \" + element.className + \" \").replace(/[\\n\\t]/g, \" \").indexOf(\" \"+my_class+\" \") > -1;\r\n\t\t}\r\n\t};\r\n\r\n\t/**\r\n\t* ImageLoader constructor.\r\n\t* ImageLoader is used for determening if all the images from the Tree are loaded.\r\n\t* \tNode size (width, height) can be correcty determined only when all inner images are loaded\r\n\t*/\r\n\tvar ImageLoader = function() {\r\n\t\tthis.loading = [];\r\n\t};\r\n\r\n\r\n\tImageLoader.prototype = {\r\n\t\tprocessNode: function(node) {\r\n\t\t\tvar images = node.nodeDOM.getElementsByTagName('img'),\r\n\t\t\t\ti =\timages.length;\r\n\t\t\twhile(i--) {\r\n\t\t\t\tthis.create(node, images[i]);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tremoveAll: function(img_src) {\r\n\t\t\tvar i = this.loading.length;\r\n\t\t\twhile (i--) {\r\n\t\t\t\tif (this.loading[i] === img_src) { this.loading.splice(i,1); }\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tcreate: function (node, image) {\r\n\r\n\t\t\tvar self = this,\r\n\t\t\t\tsource = image.src;\r\n\t\t\tthis.loading.push(source);\r\n\r\n\t\t\tfunction imgTrigger() {\r\n\t\t\t\tself.removeAll(source);\r\n\t\t\t\tnode.width = node.nodeDOM.offsetWidth;\r\n\t\t\t\tnode.height = node.nodeDOM.offsetHeight;\r\n\t\t\t}\r\n\r\n\t\t\tif (image.complete) { return imgTrigger(); }\r\n\r\n\t\t\tUTIL.addEvent(image, 'load', imgTrigger);\r\n\t\t\tUTIL.addEvent(image, 'error', imgTrigger); // handle broken url-s\r\n\r\n\t\t\t// load event is not fired for cached images, force the load event\r\n\t\t\timage.src += \"?\" + new Date().getTime();\r\n\t\t},\r\n\t\tisNotLoading: function() {\r\n\t\t\treturn this.loading.length === 0;\r\n\t\t}\r\n\t};\r\n\r\n\t/**\r\n\t* Class: TreeStore\r\n\t* TreeStore is used for holding initialized Tree objects\r\n\t* \tIts purpose is to avoid global variables and enable multiple Trees on the page.\r\n\t*/\r\n\r\n\tvar TreeStore = {\r\n\t\tstore: [],\r\n\t\tcreateTree: function(jsonConfig) {\r\n\t\t\tthis.store.push(new Tree(jsonConfig, this.store.length));\r\n\t\t\treturn this.store[this.store.length - 1]; // return newly created tree\r\n\t\t},\r\n\t\tget: function (treeId) {\r\n\t\t\treturn this.store[treeId];\r\n\t\t},\r\n\t\tdestroy: function(tree_id){\r\n\t\t\tvar tree = this.get(tree_id);\r\n\t\t\tif (tree) {\r\n\t\t\t\ttree._R.remove();\r\n\t\t\t\tvar draw_area = tree.drawArea;\r\n\t\t\t\twhile(draw_area.firstChild) {\r\n\t\t\t\t\tdraw_area.removeChild(draw_area.firstChild);\r\n\t\t\t\t}\r\n\t\t\t\tvar classes = draw_area.className.split(' '),\r\n\t\t\t\t\tclasses_to_stay = [];\r\n\t\t\t\tfor (var i = 0; i < classes.length; i++) {\r\n\t\t\t\t\tvar cls = classes[i];\r\n\t\t\t\t\tif (cls != 'Treant' && cls != 'Treant-loaded') {\r\n\t\t\t\t\t\tclasses_to_stay.push(cls);\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\t\t\t\tdraw_area.style.overflowY = '';\r\n\t\t\t\tdraw_area.style.overflowX = '';\r\n\t\t\t\tdraw_area.className = classes_to_stay.join(' ');\r\n\t\t\t\tthis.store[tree_id] = null;\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\t/**\r\n\t* Tree constructor.\r\n\t*/\r\n\tvar Tree = function (jsonConfig, treeId) {\r\n\r\n\t\tthis.id = treeId;\r\n\r\n\t\tthis.imageLoader = new ImageLoader();\r\n\t\tthis.CONFIG = UTIL.createMerge(Tree.CONFIG, jsonConfig.chart);\r\n\t\tthis.drawArea = document.getElementById(this.CONFIG.container.substring(1));\r\n\t\tthis.drawArea.className += \" Treant\";\r\n\t\tthis.nodeDB = new NodeDB(jsonConfig.nodeStructure, this);\r\n\r\n\t\t// key store for storing reference to node connectors,\r\n\t\t// key = nodeId where the connector ends\r\n\t\tthis.connectionStore = {};\r\n\t};\r\n\r\n\tTree.prototype = {\r\n\r\n\t\tpositionTree: function(callback) {\r\n\r\n\t\t\tvar self = this;\r\n\r\n\t\t\tif (this.imageLoader.isNotLoading()) {\r\n\r\n\t\t\t\tvar root = this.root(),\r\n\t\t\t\t\torient = this.CONFIG.rootOrientation;\r\n\r\n\t\t\t\tthis.resetLevelData();\r\n\r\n\t\t\t\tthis.firstWalk(root, 0);\r\n\t\t\t\tthis.secondWalk( root, 0, 0, 0 );\r\n\r\n\t\t\t\tthis.positionNodes();\r\n\r\n\t\t\t\tif (this.CONFIG.animateOnInit) {\r\n\t\t\t\t\tsetTimeout(function() { root.toggleCollapse(); }, this.CONFIG.animateOnInitDelay);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif(!this.loaded) {\r\n\t\t\t\t\tthis.drawArea.className += \" Treant-loaded\"; // nodes are hidden until .loaded class is add\r\n\t\t\t\t\tif (Object.prototype.toString.call(callback) === \"[object Function]\") { callback(self); }\r\n\t\t\t\t\tthis.loaded = true;\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\t\t\t\tsetTimeout(function() { self.positionTree(callback); }, 10);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t/*\r\n\t\t* In a first post-order walk, every node of the tree is\r\n\t\t* assigned a preliminary x-coordinate (held in field\r\n\t\t* node->flPrelim). In addition, internal nodes are\r\n\t\t* given modifiers, which will be used to move their\r\n\t\t* children to the right (held in field\r\n\t\t* node->flModifier).\r\n\t\t*/\r\n\t\tfirstWalk: function(node, level) {\r\n\r\n\t\t\tnode.prelim = null; node.modifier = null;\r\n\r\n\t\t\tthis.setNeighbors(node, level);\r\n\t\t\tthis.calcLevelDim(node, level);\r\n\r\n\t\t\tvar leftSibling = node.leftSibling();\r\n\r\n\t\t\tif(node.childrenCount() === 0 || level == this.CONFIG.maxDepth) {\r\n\t\t\t\t// set preliminary x-coordinate\r\n\t\t\t\tif(leftSibling) {\r\n\t\t\t\t\tnode.prelim = leftSibling.prelim + leftSibling.size() + this.CONFIG.siblingSeparation;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tnode.prelim = 0;\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\t\t\t\t//node is not a leaf,  firstWalk for each child\r\n\t\t\t\tfor(var i = 0, n = node.childrenCount(); i < n; i++) {\r\n\t\t\t\t\tthis.firstWalk(node.childAt(i), level + 1);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar midPoint = node.childrenCenter() - node.size() / 2;\r\n\r\n\t\t\t\tif(leftSibling) {\r\n\t\t\t\t\tnode.prelim\t\t= leftSibling.prelim + leftSibling.size() + this.CONFIG.siblingSeparation;\r\n\t\t\t\t\tnode.modifier\t= node.prelim - midPoint;\r\n\t\t\t\t\tthis.apportion( node, level );\r\n\t\t\t\t} else {\r\n\t\t\t\t\tnode.prelim = midPoint;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// handle stacked children positioning\r\n\t\t\t\tif(node.stackParent) { // hadle the parent of stacked children\r\n\t\t\t\t\tnode.modifier += this.nodeDB.get( node.stackChildren[0] ).size()/2 + node.connStyle.stackIndent;\r\n\t\t\t\t} else if ( node.stackParentId ) { // handle stacked children\r\n\t\t\t\t\tnode.prelim = 0;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t/*\r\n\t\t* Clean up the positioning of small sibling subtrees.\r\n\t\t* Subtrees of a node are formed independently and\r\n\t\t* placed as close together as possible. By requiring\r\n\t\t* that the subtrees be rigid at the time they are put\r\n\t\t* together, we avoid the undesirable effects that can\r\n\t\t* accrue from positioning nodes rather than subtrees.\r\n\t\t*/\r\n\t\tapportion: function (node, level) {\r\n\t\t\tvar firstChild\t\t\t\t= node.firstChild(),\r\n\t\t\t\tfirstChildLeftNeighbor\t= firstChild.leftNeighbor(),\r\n\t\t\t\tcompareDepth\t\t\t= 1,\r\n\t\t\t\tdepthToStop\t\t\t\t= this.CONFIG.maxDepth - level;\r\n\r\n\t\t\twhile( firstChild && firstChildLeftNeighbor && compareDepth <= depthToStop ) {\r\n\t\t\t\t// calculate the position of the firstChild, according to the position of firstChildLeftNeighbor\r\n\r\n\t\t\t\tvar modifierSumRight\t= 0,\r\n\t\t\t\t\tmodifierSumLeft\t\t= 0,\r\n\t\t\t\t\tleftAncestor\t\t= firstChildLeftNeighbor,\r\n\t\t\t\t\trightAncestor\t\t= firstChild;\r\n\r\n\t\t\t\tfor(var i = 0; i < compareDepth; i++) {\r\n\r\n\t\t\t\t\tleftAncestor\t\t= leftAncestor.parent();\r\n\t\t\t\t\trightAncestor\t\t= rightAncestor.parent();\r\n\t\t\t\t\tmodifierSumLeft\t\t+= leftAncestor.modifier;\r\n\t\t\t\t\tmodifierSumRight\t+= rightAncestor.modifier;\r\n\t\t\t\t\t// all the stacked children are oriented towards right so use right variables\r\n\t\t\t\t\tif(rightAncestor.stackParent !== undefined) modifierSumRight += rightAncestor.size()/2;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// find the gap between two trees and apply it to subTrees\r\n\t\t\t\t// and mathing smaller gaps to smaller subtrees\r\n\r\n\t\t\t\tvar totalGap = (firstChildLeftNeighbor.prelim + modifierSumLeft + firstChildLeftNeighbor.size() + this.CONFIG.subTeeSeparation) - (firstChild.prelim + modifierSumRight );\r\n\r\n\t\t\t\tif(totalGap > 0) {\r\n\r\n\t\t\t\t\tvar subtreeAux = node,\r\n\t\t\t\t\t\tnumSubtrees = 0;\r\n\r\n\t\t\t\t\t// count all the subtrees in the LeftSibling\r\n\t\t\t\t\twhile(subtreeAux && subtreeAux.id != leftAncestor.id) {\r\n\t\t\t\t\t\tsubtreeAux = subtreeAux.leftSibling();\r\n\t\t\t\t\t\tnumSubtrees++;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif(subtreeAux) {\r\n\r\n\t\t\t\t\t\tvar subtreeMoveAux = node,\r\n\t\t\t\t\t\t\tsingleGap = totalGap / numSubtrees;\r\n\r\n\t\t\t\t\t\twhile(subtreeMoveAux.id != leftAncestor.id) {\r\n\t\t\t\t\t\t\tsubtreeMoveAux.prelim\t+= totalGap;\r\n\t\t\t\t\t\t\tsubtreeMoveAux.modifier\t+= totalGap;\r\n\t\t\t\t\t\t\ttotalGap\t\t\t\t-= singleGap;\r\n\t\t\t\t\t\t\tsubtreeMoveAux = subtreeMoveAux.leftSibling();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tcompareDepth++;\r\n\r\n\t\t\t\tif(firstChild.childrenCount() === 0){\r\n\t\t\t\t\tfirstChild = node.leftMost(0, compareDepth);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tfirstChild = firstChild.firstChild();\r\n\t\t\t\t}\r\n\t\t\t\tif(firstChild) {\r\n\t\t\t\t\tfirstChildLeftNeighbor = firstChild.leftNeighbor();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t/*\r\n\t\t* During a second pre-order walk, each node is given a\r\n\t    * final x-coordinate by summing its preliminary\r\n\t    * x-coordinate and the modifiers of all the node's\r\n\t    * ancestors.  The y-coordinate depends on the height of\r\n\t    * the tree.  (The roles of x and y are reversed for\r\n\t    * RootOrientations of EAST or WEST.)\r\n\t\t*/\r\n\t\tsecondWalk: function( node, level, X, Y) {\r\n\r\n\t\t\tif(level <= this.CONFIG.maxDepth) {\r\n\t\t\t\tvar xTmp = node.prelim + X,\r\n\t\t\t\t\tyTmp = Y, align = this.CONFIG.nodeAlign,\r\n\t\t\t\t\torinet = this.CONFIG.rootOrientation,\r\n\t\t\t\t\tlevelHeight, nodesizeTmp;\r\n\r\n\t\t\t\tif (orinet == 'NORTH' || orinet == 'SOUTH') {\r\n\r\n\t\t\t\t\tlevelHeight = this.levelMaxDim[level].height;\r\n\t\t\t\t\tnodesizeTmp = node.height;\r\n\t\t\t\t\tif (node.pseudo) node.height = levelHeight; // assign a new size to pseudo nodes\r\n\t\t\t\t}\r\n\t\t\t\telse if (orinet == 'WEST' || orinet == 'EAST') {\r\n\r\n\t\t\t\t\tlevelHeight = this.levelMaxDim[level].width;\r\n\t\t\t\t\tnodesizeTmp = node.width;\r\n\t\t\t\t\tif (node.pseudo) node.width = levelHeight; // assign a new size to pseudo nodes\r\n\t\t\t\t}\r\n\r\n\t\t\t\tnode.X = xTmp;\r\n\r\n\t\t\t\tif (node.pseudo) { // pseudo nodes need to be properly aligned, otherwise position is not correct in some examples\r\n\t\t\t\t\tif (orinet == 'NORTH' || orinet == 'WEST') {\r\n\t\t\t\t\t\tnode.Y = yTmp; // align \"BOTTOM\"\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (orinet == 'SOUTH' || orinet == 'EAST') {\r\n\t\t\t\t\t\tnode.Y = (yTmp + (levelHeight - nodesizeTmp)); // align \"TOP\"\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\t\t\t\t\tnode.Y = ( align == 'CENTER' ) ? (yTmp + (levelHeight - nodesizeTmp) / 2) :\r\n\t\t\t\t\t\t\t( align == 'TOP' )\t? (yTmp + (levelHeight - nodesizeTmp)) :\r\n\t\t\t\t\t\t\tyTmp;\r\n\t\t\t\t}\r\n\r\n\r\n\t\t\t\tif(orinet == 'WEST' || orinet == 'EAST') {\r\n\t\t\t\t\tvar swapTmp = node.X;\r\n\t\t\t\t\tnode.X = node.Y;\r\n\t\t\t\t\tnode.Y = swapTmp;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (orinet == 'SOUTH') {\r\n\r\n\t\t\t\t\tnode.Y = -node.Y - nodesizeTmp;\r\n\t\t\t\t}\r\n\t\t\t\telse if (orinet == 'EAST') {\r\n\r\n\t\t\t\t\tnode.X = -node.X - nodesizeTmp;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif(node.childrenCount() !== 0) {\r\n\r\n\t\t\t\t\tif(node.id === 0 && this.CONFIG.hideRootNode) {\r\n\t\t\t\t\t\t// ako je root node Hiden onda nemoj njegovu dijecu pomaknut po Y osi za Level separation, neka ona budu na vrhu\r\n\t\t\t\t\t\tthis.secondWalk(node.firstChild(), level + 1, X + node.modifier, Y);\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tthis.secondWalk(node.firstChild(), level + 1, X + node.modifier, Y + levelHeight + this.CONFIG.levelSeparation);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif(node.rightSibling()) {\r\n\r\n\t\t\t\t\tthis.secondWalk(node.rightSibling(), level, X, Y);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t// position all the nodes, center the tree in center of its container\r\n\t\t// 0,0 coordinate is in the upper left corner\r\n\t\tpositionNodes: function() {\r\n\r\n\t\t\tvar self = this,\r\n\t\t\t\ttreeSize = {\r\n\t\t\t\t\tx: self.nodeDB.getMinMaxCoord('X', null, null),\r\n\t\t\t\t\ty: self.nodeDB.getMinMaxCoord('Y', null, null)\r\n\t\t\t\t},\r\n\r\n\t\t\t\ttreeWidth = treeSize.x.max - treeSize.x.min,\r\n\t\t\t\ttreeHeight = treeSize.y.max - treeSize.y.min,\r\n\r\n\t\t\t\ttreeCenter = {\r\n\t\t\t\t\tx: treeSize.x.max - treeWidth/2,\r\n\t\t\t\t\ty: treeSize.y.max - treeHeight/2\r\n\t\t\t\t},\r\n\r\n\t\t\t\tcontainerCenter = {\r\n\t\t\t\t\tx: self.drawArea.clientWidth/2,\r\n\t\t\t\t\ty: self.drawArea.clientHeight/2\r\n\t\t\t\t},\r\n\r\n\t\t\t\tdeltaX = containerCenter.x - treeCenter.x,\r\n\t\t\t\tdeltaY = containerCenter.y - treeCenter.y,\r\n\r\n\t\t\t\t// all nodes must have positive X or Y coordinates, handle this with offsets\r\n\t\t\t\tnegOffsetX = ((treeSize.x.min + deltaX) <= 0) ? Math.abs(treeSize.x.min) : 0,\r\n\t\t\t\tnegOffsetY = ((treeSize.y.min + deltaY) <= 0) ? Math.abs(treeSize.y.min) : 0,\r\n\t\t\t\ti, len, node;\r\n\r\n\t\t\tthis.handleOverflow(treeWidth, treeHeight);\r\n\r\n\t\t\t// position all the nodes\r\n\t\t\tfor(i =0, len = this.nodeDB.db.length; i < len; i++) {\r\n\r\n\t\t\t\tnode = this.nodeDB.get(i);\r\n\r\n\t\t\t\tif(node.id === 0 && this.CONFIG.hideRootNode) continue;\r\n\r\n\t\t\t\t// if the tree is smaller than the draw area, then center the tree within drawing area\r\n\t\t\t\tnode.X += negOffsetX + ((treeWidth < this.drawArea.clientWidth) ? deltaX : this.CONFIG.padding);\r\n\t\t\t\tnode.Y += negOffsetY + ((treeHeight < this.drawArea.clientHeight) ? deltaY : this.CONFIG.padding);\r\n\r\n\t\t\t\tvar collapsedParent = node.collapsedParent(),\r\n\t\t\t\t\thidePoint = null;\r\n\r\n\t\t\t\tif(collapsedParent) {\r\n\t\t\t\t\t// position the node behind the connector point of the parent, so future animations can be visible\r\n\t\t\t\t\thidePoint = collapsedParent.connectorPoint( true );\r\n\t\t\t\t\tnode.hide(hidePoint);\r\n\r\n\t\t\t\t} else if(node.positioned) {\r\n\t\t\t\t\t// node is allready positioned,\r\n\t\t\t\t\tnode.show();\r\n\t\t\t\t} else { // inicijalno stvaranje nodeova, postavi lokaciju\r\n\t\t\t\t\tnode.nodeDOM.style.left = node.X + 'px';\r\n\t\t\t\t\tnode.nodeDOM.style.top = node.Y + 'px';\r\n\r\n\t\t\t\t\tnode.positioned = true;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (node.id !== 0 && !(node.parent().id === 0 && this.CONFIG.hideRootNode)) {\r\n\t\t\t\t\tthis.setConnectionToParent(node, hidePoint); // skip the root node\r\n\t\t\t\t}\r\n\t\t\t\telse if (!this.CONFIG.hideRootNode && node.drawLineThrough) {\r\n\t\t\t\t\t// drawlinethrough is performed for for the root node also\r\n\t\t\t\t\tnode.drawLineThroughMe();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t\t// create Raphael instance, set scrollbars if necessary\r\n\t\thandleOverflow: function(treeWidth, treeHeight) {\r\n\r\n\t\t\tvar viewWidth = (treeWidth < this.drawArea.clientWidth) ? this.drawArea.clientWidth : treeWidth + this.CONFIG.padding*2,\r\n\t\t\t\tviewHeight = (treeHeight < this.drawArea.clientHeight) ? this.drawArea.clientHeight : treeHeight + this.CONFIG.padding*2;\r\n\r\n\t\t\tif(this._R) {\r\n\t\t\t\tthis._R.setSize(viewWidth, viewHeight);\r\n\t\t\t} else {\r\n\t\t\t\tthis._R = Raphael(this.drawArea, viewWidth, viewHeight);\r\n\t\t\t}\r\n\r\n\r\n\t\t\tif(this.CONFIG.scrollbar == 'native') {\r\n\r\n\t\t\t\tif(this.drawArea.clientWidth < treeWidth) { // is owerflow-x necessary\r\n\t\t\t\t\tthis.drawArea.style.overflowX = \"auto\";\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif(this.drawArea.clientHeight < treeHeight) { // is owerflow-y necessary\r\n\t\t\t\t\tthis.drawArea.style.overflowY = \"auto\";\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if (this.CONFIG.scrollbar == 'fancy') {\r\n\r\n\t\t\t\tvar jq_drawArea = $(this.drawArea);\r\n\t\t\t\tif (jq_drawArea.hasClass('ps-container')) { // znaci da je 'fancy' vec inicijaliziran, treba updateat\r\n\r\n\t\t\t\t\tjq_drawArea.find('.Treant').css({\r\n\t\t\t\t\t\twidth: viewWidth,\r\n\t\t\t\t\t\theight: viewHeight\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t\tjq_drawArea.perfectScrollbar('update');\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tvar mainContiner = jq_drawArea.wrapInner('<div class=\"Treant\"/>'),\r\n\t\t\t\t\t\tchild = mainContiner.find('.Treant');\r\n\r\n\t\t\t\t\tchild.css({\r\n\t\t\t\t\t\twidth: viewWidth,\r\n\t\t\t\t\t\theight: viewHeight\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t\tmainContiner.perfectScrollbar();\r\n\t\t\t\t}\r\n\t\t\t} // else this.CONFIG.scrollbar == 'None'\r\n\r\n\t\t},\r\n\r\n\t\tsetConnectionToParent: function(node, hidePoint) {\r\n\r\n\t\t\tvar stacked = node.stackParentId,\r\n\t\t\t\tconnLine,\r\n\t\t\t\tparent = stacked ? this.nodeDB.get(stacked) : node.parent(),\r\n\r\n\t\t\t\tpathString = hidePoint ? this.getPointPathString(hidePoint):\r\n\t\t\t\t\t\t\tthis.getPathString(parent, node, stacked);\r\n\r\n\r\n\t\t\tif (this.connectionStore[node.id]) {\r\n\t\t\t\t// connector allready exists, update the connector geometry\r\n\t\t\t\tconnLine = this.connectionStore[node.id];\r\n\t\t\t\tthis.animatePath(connLine, pathString);\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tconnLine = this._R.path( pathString );\r\n\t\t\t\tthis.connectionStore[node.id] = connLine;\r\n\r\n\t\t\t\t// don't show connector arrows por pseudo nodes\r\n\t\t\t\tif(node.pseudo) { delete parent.connStyle.style['arrow-end']; }\r\n\t\t\t\tif(parent.pseudo) { delete parent.connStyle.style['arrow-start']; }\r\n\r\n\t\t\t\tconnLine.attr(parent.connStyle.style);\r\n\r\n\t\t\t\tif(node.drawLineThrough || node.pseudo) { node.drawLineThroughMe(hidePoint); }\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t// create the path which is represanted as a point, used for hiding the connection\r\n\t\tgetPointPathString: function(hp) {\r\n\t\t\t// \"_\" indicates the path will be hidden\r\n\t\t\treturn [\"_M\", hp.x, \",\", hp.y, 'L', hp.x, \",\", hp.y, hp.x, \",\", hp.y].join(\" \");\r\n\t\t},\r\n\r\n\t\tanimatePath: function(path, pathString) {\r\n\r\n\r\n\t\t\tif (path.hidden && pathString.charAt(0) !== \"_\") { // path will be shown, so show it\r\n\t\t\t\tpath.show();\r\n\t\t\t\tpath.hidden = false;\r\n\t\t\t}\r\n\r\n\t\t\tpath.animate({\r\n\t\t\t\tpath: pathString.charAt(0) === \"_\" ? pathString.substring(1) : pathString // remove the \"_\" prefix if it exists\r\n\t\t\t}, this.CONFIG.animation.connectorsSpeed,  this.CONFIG.animation.connectorsAnimation,\r\n\t\t\tfunction(){\r\n\t\t\t\tif(pathString.charAt(0) === \"_\") { // animation is hiding the path, hide it at the and of animation\r\n\t\t\t\t\tpath.hide();\r\n\t\t\t\t\tpath.hidden = true;\r\n\t\t\t\t}\r\n\r\n\t\t\t});\r\n\r\n\t\t},\r\n\r\n\t\tgetPathString: function(from_node, to_node, stacked) {\r\n\r\n\t\t\tvar startPoint = from_node.connectorPoint( true ),\r\n\t\t\t\tendPoint = to_node.connectorPoint( false ),\r\n\t\t\t\torinet = this.CONFIG.rootOrientation,\r\n\t\t\t\tconnType = from_node.connStyle.type,\r\n\t\t\t\tP1 = {}, P2 = {};\r\n\r\n\t\t\tif (orinet == 'NORTH' || orinet == 'SOUTH') {\r\n\t\t\t\tP1.y = P2.y = (startPoint.y + endPoint.y) / 2;\r\n\r\n\t\t\t\tP1.x = startPoint.x;\r\n\t\t\t\tP2.x = endPoint.x;\r\n\r\n\t\t\t} else if (orinet == 'EAST' || orinet == 'WEST') {\r\n\t\t\t\tP1.x = P2.x = (startPoint.x + endPoint.x) / 2;\r\n\r\n\t\t\t\tP1.y = startPoint.y;\r\n\t\t\t\tP2.y = endPoint.y;\r\n\t\t\t}\r\n\r\n\t\t\t// sp, p1, pm, p2, ep == \"x,y\"\r\n\t\t\tvar sp = startPoint.x+','+startPoint.y, p1 = P1.x+','+P1.y, p2 = P2.x+','+P2.y, ep = endPoint.x+','+endPoint.y,\r\n\t\t\t\tpm = (P1.x + P2.x)/2 +','+ (P1.y + P2.y)/2, pathString, stackPoint;\r\n\r\n\t\t\tif(stacked) { // STACKED CHILDREN\r\n\r\n\t\t\t\tstackPoint = (orinet == 'EAST' || orinet == 'WEST') ?\r\n\t\t\t\t\t\t\t\tendPoint.x+','+startPoint.y :\r\n\t\t\t\t\t\t\t\tstartPoint.x+','+endPoint.y;\r\n\r\n\t\t\t\tif( connType == \"step\" || connType == \"straight\" ) {\r\n\r\n\t\t\t\t\tpathString = [\"M\", sp, 'L', stackPoint, 'L', ep];\r\n\r\n\t\t\t\t} else if ( connType == \"curve\" || connType == \"bCurve\" ) {\r\n\r\n\t\t\t\t\tvar helpPoint, // used for nicer curve lines\r\n\t\t\t\t\t\tindent = from_node.connStyle.stackIndent;\r\n\r\n\t\t\t\t\tif (orinet == 'NORTH') {\r\n\t\t\t\t\t\thelpPoint = (endPoint.x - indent)+','+(endPoint.y - indent);\r\n\t\t\t\t\t} else if (orinet == 'SOUTH') {\r\n\t\t\t\t\t\thelpPoint = (endPoint.x - indent)+','+(endPoint.y + indent);\r\n\t\t\t\t\t} else if (orinet == 'EAST') {\r\n\t\t\t\t\t\thelpPoint = (endPoint.x + indent) +','+startPoint.y;\r\n\t\t\t\t\t} else if ( orinet == 'WEST') {\r\n\t\t\t\t\t\thelpPoint = (endPoint.x - indent) +','+startPoint.y;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tpathString = [\"M\", sp, 'L', helpPoint, 'S', stackPoint, ep];\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {  // NORAML CHILDREN\r\n\r\n\t\t\t\tif( connType == \"step\" ) {\r\n\t\t\t\t\tpathString = [\"M\", sp, 'L', p1, 'L', p2, 'L', ep];\r\n\t\t\t\t} else if ( connType == \"curve\" ) {\r\n\t\t\t\t\tpathString = [\"M\", sp, 'C', p1, p2, ep ];\r\n\t\t\t\t} else if ( connType == \"bCurve\" ) {\r\n\t\t\t\t\tpathString = [\"M\", sp, 'Q', p1, pm, 'T', ep];\r\n\t\t\t\t} else if (connType == \"straight\" ) {\r\n\t\t\t\t\tpathString = [\"M\", sp, 'L', sp, ep];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn pathString.join(\" \");\r\n\t\t},\r\n\r\n\t\t// algorithm works from left to right, so previous processed node will be left neigbor of the next node\r\n\t\tsetNeighbors: function(node, level) {\r\n\r\n\t\t\tnode.leftNeighborId = this.lastNodeOnLevel[level];\r\n\t\t\tif(node.leftNeighborId) node.leftNeighbor().rightNeighborId = node.id;\r\n\t\t\tthis.lastNodeOnLevel[level] = node.id;\r\n\t\t},\r\n\r\n\t\t// used for calculation of height and width of a level (level dimensions)\r\n\t\tcalcLevelDim: function(node, level) { // root node is on level 0\r\n\t\t\tif (this.levelMaxDim[level]) {\r\n\t\t\t\tif( this.levelMaxDim[level].width < node.width )\r\n\t\t\t\t\tthis.levelMaxDim[level].width = node.width;\r\n\r\n\t\t\t\tif( this.levelMaxDim[level].height < node.height )\r\n\t\t\t\t\tthis.levelMaxDim[level].height = node.height;\r\n\r\n\t\t\t} else {\r\n\t\t\t\tthis.levelMaxDim[level] = { width: node.width, height: node.height };\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tresetLevelData: function() {\r\n\t\t\tthis.lastNodeOnLevel = [];\r\n\t\t\tthis.levelMaxDim = [];\r\n\t\t},\r\n\r\n\t\troot: function() {\r\n\t\t\treturn this.nodeDB.get( 0 );\r\n\t\t}\r\n\t};\r\n\r\n\t/**\r\n\t* NodeDB constructor.\r\n\t* NodeDB is used for storing the nodes. Each tree has its own NodeDB.\r\n\t*/\r\n\tvar NodeDB = function (nodeStructure, tree) {\r\n\r\n\t\tthis.db\t= [];\r\n\r\n\t\tvar self = this;\r\n\r\n\t\tfunction itterateChildren(node, parentId) {\r\n\r\n\t\t\tvar newNode = self.createNode(node, parentId, tree, null);\r\n\r\n\t\t\tif(node.children) {\r\n\r\n\t\t\t\tnewNode.children = [];\r\n\r\n\t\t\t\t// pseudo node is used for descending children to the next level\r\n\t\t\t\tif(node.childrenDropLevel && node.childrenDropLevel > 0) {\r\n\t\t\t\t\twhile(node.childrenDropLevel--) {\r\n\t\t\t\t\t\t// pseudo node needs to inherit the connection style from its parent for continuous connectors\r\n\t\t\t\t\t\tvar connStyle = UTIL.cloneObj(newNode.connStyle);\r\n\t\t\t\t\t\tnewNode = self.createNode('pseudo', newNode.id, tree, null);\r\n\t\t\t\t\t\tnewNode.connStyle = connStyle;\r\n\t\t\t\t\t\tnewNode.children = [];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar stack = (node.stackChildren && !self.hasGrandChildren(node)) ? newNode.id : null;\r\n\r\n\t\t\t\t// svildren are position on separate leves, one beneeth the other\r\n\t\t\t\tif (stack !== null) { newNode.stackChildren = []; }\r\n\r\n\t\t\t\tfor (var i = 0, len = node.children.length; i < len ; i++) {\r\n\r\n\t\t\t\t\tif (stack !== null) {\r\n\t\t\t\t\t\tnewNode =  self.createNode(node.children[i], newNode.id, tree, stack);\r\n\t\t\t\t\t\tif((i + 1) < len) newNode.children = []; // last node cant have children\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\titterateChildren(node.children[i], newNode.id);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (tree.CONFIG.animateOnInit) nodeStructure.collapsed = true;\r\n\r\n\t\titterateChildren( nodeStructure, -1); // root node\r\n\r\n\t\tthis.createGeometries(tree);\r\n\t};\r\n\r\n\tNodeDB.prototype = {\r\n\r\n\t\tcreateGeometries: function(tree) {\r\n\t\t\tvar i = this.db.length, node;\r\n\t\t\twhile(i--) {\r\n\t\t\t\tthis.get(i).createGeometry(tree);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tget: function (nodeId) {\r\n\t\t\treturn this.db[nodeId]; // get node by ID\r\n\t\t},\r\n\r\n\t\tcreateNode: function(nodeStructure, parentId, tree, stackParentId) {\r\n\r\n\t\t\tvar node = new TreeNode( nodeStructure, this.db.length, parentId, tree, stackParentId );\r\n\r\n\t\t\tthis.db.push( node );\r\n\t\t\tif( parentId >= 0 ) this.get( parentId ).children.push( node.id ); //skip root node\r\n\r\n\t\t\tif( stackParentId ) {\r\n\t\t\t\tthis.get( stackParentId ).stackParent = true;\r\n\t\t\t\tthis.get( stackParentId ).stackChildren.push( node.id );\r\n\t\t\t}\r\n\r\n\t\t\treturn node;\r\n\t\t},\r\n\r\n\t\tgetMinMaxCoord: function( dim, parent, MinMax ) { // used for getting the dimensions of the tree, dim = 'X' || 'Y'\r\n\t\t\t// looks for min and max (X and Y) within the set of nodes\r\n\t\t\tvar parent = parent || this.get(0),\r\n\t\t\t \ti = parent.childrenCount(),\r\n\t\t\t\tMinMax = MinMax || { // start with root node dimensions\r\n\t\t\t\t\tmin: parent[dim],\r\n\t\t\t\t\tmax: parent[dim] + ((dim == 'X') ? parent.width : parent.height)\r\n\t\t\t\t};\r\n\r\n\t\t\twhile(i--) {\r\n\r\n\t\t\t\tvar node = parent.childAt(i),\r\n\t\t\t\t\tmaxTest = node[dim] + ((dim == 'X') ? node.width : node.height),\r\n\t\t\t\t\tminTest = node[dim];\r\n\r\n\t\t\t\tif (maxTest > MinMax.max) {\r\n\t\t\t\t\tMinMax.max = maxTest;\r\n\r\n\t\t\t\t}\r\n\t\t\t\tif (minTest < MinMax.min) {\r\n\t\t\t\t\tMinMax.min = minTest;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.getMinMaxCoord(dim, node, MinMax);\r\n\t\t\t}\r\n\t\t\treturn MinMax;\r\n\t\t},\r\n\r\n\t\thasGrandChildren: function(nodeStructure) {\r\n\t\t\tvar i = nodeStructure.children.length;\r\n\t\t\twhile(i--) {\r\n\t\t\t\tif(nodeStructure.children[i].children) return true;\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\r\n\t/**\r\n\t* TreeNode constructor.\r\n\t* @constructor\r\n\t*/\r\n\tvar TreeNode = function (nodeStructure, id, parentId, tree, stackParentId) {\r\n\r\n\t\tthis.id\t\t\t= id;\r\n\t\tthis.parentId\t= parentId;\r\n\t\tthis.treeId\t\t= tree.id;\r\n\t\tthis.prelim\t\t= 0;\r\n\t\tthis.modifier\t= 0;\r\n\r\n\t\tthis.stackParentId = stackParentId;\r\n\r\n\t\t// pseudo node is a node with width=height=0, it is invisible, but necessary for the correct positiong of the tree\r\n\t\tthis.pseudo = nodeStructure === 'pseudo' || nodeStructure['pseudo'];\r\n\r\n\t\tthis.image = nodeStructure.image;\r\n\r\n\t\tthis.link = UTIL.createMerge( tree.CONFIG.node.link,  nodeStructure.link);\r\n\r\n\t\tthis.connStyle = UTIL.createMerge(tree.CONFIG.connectors, nodeStructure.connectors);\r\n\r\n\t\tthis.drawLineThrough = nodeStructure.drawLineThrough === false ? false : nodeStructure.drawLineThrough || tree.CONFIG.node.drawLineThrough;\r\n\r\n\t\tthis.collapsable = nodeStructure.collapsable === false ? false : nodeStructure.collapsable || tree.CONFIG.node.collapsable;\r\n\t\tthis.collapsed = nodeStructure.collapsed;\r\n\r\n\t\tthis.text = nodeStructure.text;\r\n\r\n\t\t// '.node' DIV\r\n\t\tthis.nodeInnerHTML\t= nodeStructure.innerHTML;\r\n\t\tthis.nodeHTMLclass\t= (tree.CONFIG.node.HTMLclass ? tree.CONFIG.node.HTMLclass : '') + // globaly defined class for the nodex\r\n\t\t\t\t\t\t\t\t(nodeStructure.HTMLclass ? (' ' + nodeStructure.HTMLclass) : '');\t\t// + specific node class\r\n\r\n\t\tthis.nodeHTMLid\t\t= nodeStructure.HTMLid;\r\n\t};\r\n\r\n\tTreeNode.prototype = {\r\n\r\n\t\tTree: function() {\r\n\t\t\treturn TreeStore.get(this.treeId);\r\n\t\t},\r\n\r\n\t\tdbGet: function(nodeId) {\r\n\t\t\treturn this.Tree().nodeDB.get(nodeId);\r\n\t\t},\r\n\r\n\t\tsize: function() { // returns the width of the node\r\n\t\t\tvar orient = this.Tree().CONFIG.rootOrientation;\r\n\r\n\t\t\tif(this.pseudo) return - this.Tree().CONFIG.subTeeSeparation; // prevents of separateing the subtrees\r\n\r\n\t\t\tif (orient == 'NORTH' || orient == 'SOUTH')\r\n\t\t\t\treturn this.width;\r\n\r\n\t\t\telse if (orient == 'WEST' || orient == 'EAST')\r\n\t\t\t\treturn this.height;\r\n\t\t},\r\n\r\n\t\tchildrenCount: function () {\r\n\t\t\treturn\t(this.collapsed || !this.children) ? 0 : this.children.length;\r\n\t\t},\r\n\r\n\t\tchildAt: function(i) {\r\n\t\t\treturn this.dbGet( this.children[i] );\r\n\t\t},\r\n\r\n\t\tfirstChild: function() {\r\n\t\t\treturn this.childAt(0);\r\n\t\t},\r\n\r\n\t\tlastChild: function() {\r\n\t\t\treturn this.childAt( this.children.length - 1 );\r\n\t\t},\r\n\r\n\t\tparent: function() {\r\n\t\t\treturn this.dbGet( this.parentId );\r\n\t\t},\r\n\r\n\t\tleftNeighbor: function() {\r\n\t\t\tif( this.leftNeighborId ) return this.dbGet( this.leftNeighborId );\r\n\t\t},\r\n\r\n\t\trightNeighbor: function() {\r\n\t\t\tif( this.rightNeighborId ) return this.dbGet( this.rightNeighborId );\r\n\t\t},\r\n\r\n\t\tleftSibling: function () {\r\n\t\t\tvar leftNeighbor = this.leftNeighbor();\r\n\r\n\t\t\tif( leftNeighbor && leftNeighbor.parentId == this.parentId ) return leftNeighbor;\r\n\t\t},\r\n\r\n\t\trightSibling: function () {\r\n\t\t\tvar rightNeighbor = this.rightNeighbor();\r\n\r\n\t\t\tif( rightNeighbor && rightNeighbor.parentId == this.parentId ) return rightNeighbor;\r\n\t\t},\r\n\r\n\t\tchildrenCenter: function ( tree ) {\r\n\t\t\tvar first = this.firstChild(),\r\n\t\t\t\tlast = this.lastChild();\r\n\t\t\treturn first.prelim + ((last.prelim - first.prelim) + last.size()) / 2;\r\n\t\t},\r\n\r\n\t\t// find out if one of the node ancestors is collapsed\r\n\t\tcollapsedParent: function() {\r\n\t\t\tvar parent = this.parent();\r\n\t\t\tif (!parent) return false;\r\n\t\t\tif (parent.collapsed) return parent;\r\n\t\t\treturn parent.collapsedParent();\r\n\t\t},\r\n\r\n\t\tleftMost: function ( level, depth ) { // returns the leftmost child at specific level, (initaial level = 0)\r\n\r\n\t\t\tif( level >= depth ) return this;\r\n\t\t\tif( this.childrenCount() === 0 ) return;\r\n\r\n\t\t\tfor(var i = 0, n = this.childrenCount(); i < n; i++) {\r\n\r\n\t\t\t\tvar leftmostDescendant = this.childAt(i).leftMost( level + 1, depth );\r\n\t\t\t\tif(leftmostDescendant)\r\n\t\t\t\t\treturn leftmostDescendant;\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t// returns start or the end point of the connector line, origin is upper-left\r\n\t\tconnectorPoint: function(startPoint) {\r\n\t\t\tvar orient = this.Tree().CONFIG.rootOrientation, point = {};\r\n\r\n\t\t\tif(this.stackParentId) { // return different end point if node is a stacked child\r\n\t\t\t\tif (orient == 'NORTH' || orient == 'SOUTH') { orient = 'WEST'; }\r\n\t\t\t\telse if (orient == 'EAST' || orient == 'WEST') { orient = 'NORTH'; }\r\n\t\t\t}\r\n\t\t\t// if pseudo, a virtual center is used\r\n\t\t\tif (orient == 'NORTH') {\r\n\r\n\t\t\t\tpoint.x = (this.pseudo) ? this.X - this.Tree().CONFIG.subTeeSeparation/2 : this.X + this.width/2;\r\n\t\t\t\tpoint.y = (startPoint) ? this.Y + this.height : this.Y;\r\n\r\n\t\t\t} else if (orient == 'SOUTH') {\r\n\r\n\t\t\t\tpoint.x = (this.pseudo) ? this.X - this.Tree().CONFIG.subTeeSeparation/2 : this.X + this.width/2;\r\n\t\t\t\tpoint.y = (startPoint) ? this.Y : this.Y + this.height;\r\n\r\n\t\t\t} else if (orient == 'EAST') {\r\n\r\n\t\t\t\tpoint.x = (startPoint) ? this.X : this.X + this.width;\r\n\t\t\t\tpoint.y = (this.pseudo) ? this.Y - this.Tree().CONFIG.subTeeSeparation/2 : this.Y + this.height/2;\r\n\r\n\t\t\t} else if (orient == 'WEST') {\r\n\r\n\t\t\t\tpoint.x = (startPoint) ? this.X + this.width : this.X;\r\n\t\t\t\tpoint.y =  (this.pseudo) ? this.Y - this.Tree().CONFIG.subTeeSeparation/2 : this.Y + this.height/2;\r\n\t\t\t}\r\n\t\t\treturn point;\r\n\t\t},\r\n\r\n\t\tpathStringThrough: function() { // get the geometry of a path going through the node\r\n\t\t\tvar startPoint = this.connectorPoint(true),\r\n\t\t\t\tendPoint = this.connectorPoint(false);\r\n\r\n\t\t\treturn [\"M\", startPoint.x+\",\"+startPoint.y, 'L', endPoint.x+\",\"+endPoint.y].join(\" \");\r\n\t\t},\r\n\r\n\t\tdrawLineThroughMe: function(hidePoint) { // hidepoint se proslijedjuje ako je node sakriven zbog collapsed\r\n\r\n\t\t\tvar pathString = hidePoint ? this.Tree().getPointPathString(hidePoint) : this.pathStringThrough();\r\n\r\n\t\t\tthis.lineThroughMe = this.lineThroughMe || this.Tree()._R.path(pathString);\r\n\r\n\t\t\tvar line_style = UTIL.cloneObj(this.connStyle.style);\r\n\r\n\t\t\tdelete line_style['arrow-start'];\r\n\t\t\tdelete line_style['arrow-end'];\r\n\r\n\t\t\tthis.lineThroughMe.attr( line_style );\r\n\r\n\t\t\tif(hidePoint) {\r\n\t\t\t\tthis.lineThroughMe.hide();\r\n\t\t\t\tthis.lineThroughMe.hidden = true;\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\taddSwitchEvent: function(my_switch) {\r\n\t\t\tvar self = this;\r\n\t\t\tUTIL.addEvent(my_switch, 'click', function(e){\r\n\t\t\t\te.preventDefault();\r\n\t\t\t\tself.toggleCollapse();\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\ttoggleCollapse: function() {\r\n\t\t\tvar tree = this.Tree();\r\n\r\n\t\t\tif (! tree.inAnimation) {\r\n\r\n\t\t\t\ttree.inAnimation = true;\r\n\r\n\t\t\t\tthis.collapsed = !this.collapsed; // toglle the collapse at each click\r\n\t\t\t\tif (this.collapsed) {\r\n\t\t\t\t\t$(this.nodeDOM).addClass('collapsed');\r\n\t\t\t\t} else {\r\n\t\t\t\t\t$(this.nodeDOM).removeClass('collapsed');\r\n\t\t\t\t}\r\n\t\t\t\ttree.positionTree();\r\n\r\n\t\t\t\tsetTimeout(function() { // set the flag after the animation\r\n\t\t\t\t\ttree.inAnimation = false;\r\n\t\t\t\t}, tree.CONFIG.animation.nodeSpeed > tree.CONFIG.animation.connectorsSpeed ? tree.CONFIG.animation.nodeSpeed : tree.CONFIG.animation.connectorsSpeed)\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\thide: function(collapse_to_point) {\r\n\t\t\tthis.nodeDOM.style.overflow = \"hidden\";\r\n\r\n\t\t\tvar jq_node = $(this.nodeDOM), tree = this.Tree(),\r\n\t\t\t\tconfig = tree.CONFIG,\r\n\t\t\t\tnew_pos = {\r\n\t\t\t\t\tleft: collapse_to_point.x,\r\n\t\t\t\t\ttop: collapse_to_point.y\r\n\t\t\t\t};\r\n\r\n\t\t\tif (!this.hidden) { new_pos.width = new_pos.height = 0; }\r\n\r\n\t\t\tif(!this.startW || !this.startH) { this.startW = jq_node.outerWidth(); this.startH = jq_node.outerHeight(); }\r\n\r\n\t\t\t// if parent was hidden in initial configuration, position the node behind the parent without animations\r\n\t\t\tif(!this.positioned || this.hidden) {\r\n\t\t\t\tthis.nodeDOM.style.visibility = 'hidden';\r\n\t\t\t\tjq_node.css(new_pos);\r\n\t\t\t\tthis.positioned = true;\r\n\t\t\t} else {\r\n\t\t\t\tjq_node.animate(new_pos, config.animation.nodeSpeed, config.animation.nodeAnimation,\r\n\t\t\t\tfunction(){\r\n\t\t\t\t\tthis.style.visibility = 'hidden';\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\t// animate the line through node if the line exists\r\n\t\t\tif(this.lineThroughMe) {\r\n\t\t\t\tvar new_path = tree.getPointPathString(collapse_to_point);\r\n\t\t\t\tif (this.hidden) {\r\n\t\t\t\t\t// update without animations\r\n\t\t\t\t\tthis.lineThroughMe.attr({path: new_path});\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// update with animations\r\n\t\t\t\t\ttree.animatePath(this.lineThroughMe, tree.getPointPathString(collapse_to_point));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tthis.hidden = true;\r\n\t\t},\r\n\r\n\t\tshow: function() {\r\n\t\t\tthis.nodeDOM.style.visibility = 'visible';\r\n\r\n\t\t\tvar new_pos = {\r\n\t\t\t\tleft: this.X,\r\n\t\t\t\ttop: this.Y\r\n\t\t\t},\r\n\t\t\ttree = this.Tree(),  config = tree.CONFIG;\r\n\r\n\t\t\t// if the node was hidden, update width and height\r\n\t\t\tif(this.hidden) {\r\n\t\t\t\tnew_pos.width = this.startW;\r\n\t\t\t\tnew_pos.height = this.startH;\r\n\t\t\t}\r\n\r\n\t\t\t$(this.nodeDOM).animate(\r\n\t\t\t\tnew_pos,\r\n\t\t\t\tconfig.animation.nodeSpeed, config.animation.nodeAnimation,\r\n\t\t\t\tfunction() {\r\n\t\t\t\t\t// $.animate applys \"overflow:hidden\" to the node, remove it to avoid visual problems\r\n\t\t\t\t\tthis.style.overflow = \"\";\r\n\t\t\t\t}\r\n\t\t\t);\r\n\r\n\t\t\tif(this.lineThroughMe) {\r\n\t\t\t\ttree.animatePath(this.lineThroughMe, this.pathStringThrough());\r\n\t\t\t}\r\n\r\n\t\t\tthis.hidden = false;\r\n\t\t}\r\n\t};\r\n\r\n\tTreeNode.prototype.createGeometry = function(tree) {\r\n\r\n\t\tif (this.id === 0 && tree.CONFIG.hideRootNode) {\r\n\t\t\tthis.width = 0; this.height = 0;\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar drawArea = tree.drawArea,\r\n\t\t\timage, i,\r\n\r\n\t\t/////////// CREATE NODE //////////////\r\n\t\tnode = this.link.href ? document.createElement('a') : document.createElement('div');\r\n\r\n\t\tnode.className = (!this.pseudo) ? TreeNode.CONFIG.nodeHTMLclass : 'pseudo';\r\n\t\tif(this.nodeHTMLclass && !this.pseudo) node.className += ' ' + this.nodeHTMLclass;\r\n\r\n\t\tif(this.nodeHTMLid) node.id = this.nodeHTMLid;\r\n\r\n\t\tif(this.link.href) {\r\n\t\t\tnode.href = this.link.href;\r\n\t\t\tnode.target = this.link.target;\r\n\t\t}\r\n\r\n\t\t/////////// CREATE innerHTML //////////////\r\n\t\tif (!this.pseudo) {\r\n\t\t\tif (!this.nodeInnerHTML) {\r\n\r\n\t\t\t\t// IMAGE\r\n\t\t\t\tif(this.image) {\r\n\t\t\t\t\timage = document.createElement('img');\r\n\r\n\t\t\t\t\timage.src = this.image;\r\n\t\t\t\t\tnode.appendChild(image);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// TEXT\r\n\t\t\t\tif(this.text) {\r\n\t\t\t\t\tfor(var key in this.text) {\r\n\t\t\t\t\t\tif(TreeNode.CONFIG.textClass[key]) {\r\n\t\t\t\t\t\t\tvar text = document.createElement(this.text[key].href ? 'a' : 'p');\r\n\r\n\t\t\t\t\t\t\t// meke an <a> element if required\r\n\t\t\t\t\t\t\tif (this.text[key].href) {\r\n\t\t\t\t\t\t\t\ttext.href = this.text[key].href;\r\n\t\t\t\t\t\t\t\tif (this.text[key].target) { text.target = this.text[key].target; }\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\ttext.className = TreeNode.CONFIG.textClass[key];\r\n\t\t\t\t\t\t\ttext.appendChild(document.createTextNode(\r\n\t\t\t\t\t\t\t\tthis.text[key].val ? this.text[key].val :\r\n\t\t\t\t\t\t\t\t\tthis.text[key] instanceof Object ? \"'val' param missing!\" : this.text[key]\r\n\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\t\tnode.appendChild(text);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// get some element by ID and clone its structure into a node\r\n\t\t\t\tif (this.nodeInnerHTML.charAt(0) === \"#\") {\r\n\t\t\t\t\tvar elem = document.getElementById(this.nodeInnerHTML.substring(1));\r\n\t\t\t\t\tif (elem) {\r\n\t\t\t\t\t\tnode = elem.cloneNode(true);\r\n\t\t\t\t\t\tnode.id += \"-clone\";\r\n\t\t\t\t\t\tnode.className += \" node\";\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tnode.innerHTML = \"<b> Wrong ID selector </b>\";\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// insert your custom HTML into a node\r\n\t\t\t\t\tnode.innerHTML = this.nodeInnerHTML;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// handle collapse switch\r\n\t\t\tif (this.collapsed || (this.collapsable && this.childrenCount() && !this.stackParentId)) {\r\n\t\t\t\tvar my_switch = document.createElement('a');\r\n\t\t\t\tmy_switch.className = \"collapse-switch\";\r\n\t\t\t\tnode.appendChild(my_switch);\r\n\t\t\t\tthis.addSwitchEvent(my_switch);\r\n\t\t\t\tif (this.collapsed) { node.className += \" collapsed\"; }\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/////////// APPEND all //////////////\r\n\t\tdrawArea.appendChild(node);\r\n\r\n\t\tthis.width = node.offsetWidth;\r\n\t\tthis.height = node.offsetHeight;\r\n\r\n\t\tthis.nodeDOM = node;\r\n\r\n\t\ttree.imageLoader.processNode(this);\r\n\t};\r\n\r\n\r\n\r\n\t// ###########################################\r\n\t//\t\tExpose global + default CONFIG params\r\n\t// ###########################################\r\n\r\n\r\n\tTree.CONFIG = {\r\n\t\tmaxDepth: 100,\r\n\t\trootOrientation: 'NORTH', // NORTH || EAST || WEST || SOUTH\r\n\t\tnodeAlign: 'CENTER', // CENTER || TOP || BOTTOM\r\n\t\tlevelSeparation: 30,\r\n\t\tsiblingSeparation: 30,\r\n\t\tsubTeeSeparation: 30,\r\n\r\n\t\thideRootNode: false,\r\n\r\n\t\tanimateOnInit: false,\r\n\t\tanimateOnInitDelay: 500,\r\n\r\n\t\tpadding: 15, // the difference is seen only when the scrollbar is shown\r\n\t\tscrollbar: 'native', // \"native\" || \"fancy\" || \"None\" (PS: \"fancy\" requires jquery and perfect-scrollbar)\r\n\r\n\t\tconnectors: {\r\n\r\n\t\t\ttype: 'curve', // 'curve' || 'step' || 'straight' || 'bCurve'\r\n\t\t\tstyle: {\r\n\t\t\t\tstroke: 'black'\r\n\t\t\t},\r\n\t\t\tstackIndent: 15\r\n\t\t},\r\n\r\n\t\tnode: { // each node inherits this, it can all be overrifen in node config\r\n\r\n\t\t\t// HTMLclass: 'node',\r\n\t\t\t// drawLineThrough: false,\r\n\t\t\t// collapsable: false,\r\n\t\t\tlink: {\r\n\t\t\t\ttarget: '_self'\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tanimation: { // each node inherits this, it can all be overrifen in node config\r\n\r\n\t\t\tnodeSpeed: 450,\r\n\t\t\tnodeAnimation: 'linear',\r\n\t\t\tconnectorsSpeed: 450,\r\n\t\t\tconnectorsAnimation: 'linear'\r\n\t\t}\r\n\t};\r\n\r\n\tTreeNode.CONFIG = {\r\n\t\tnodeHTMLclass: 'node',\r\n\r\n\t\ttextClass: {\r\n\t\t\tname:\t'node-name',\r\n\t\t\ttitle:\t'node-title',\r\n\t\t\tdesc:\t'node-desc',\r\n\t\t\tcontact: 'node-contact'\r\n\t\t}\r\n\t};\r\n\r\n\t// #############################################\r\n\t// Makes a JSON chart config out of Array config\r\n\t// #############################################\r\n\r\n\tvar JSONconfig = {\r\n\t\tmake: function( configArray ) {\r\n\r\n\t\t\tvar i = configArray.length, node;\r\n\r\n\t\t\tthis.jsonStructure = {\r\n\t\t\t\tchart: null,\r\n\t\t\t\tnodeStructure: null\r\n\t\t\t};\r\n\t\t\t//fist loop: find config, find root;\r\n\t\t\twhile(i--) {\r\n\t\t\t\tnode = configArray[i];\r\n\t\t\t\tif (node.hasOwnProperty('container')) {\r\n\t\t\t\t\tthis.jsonStructure.chart = node;\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (!node.hasOwnProperty('parent') && ! node.hasOwnProperty('container')) {\r\n\t\t\t\t\tthis.jsonStructure.nodeStructure = node;\r\n\t\t\t\t\tnode.myID = this.getID();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tthis.findChildren(configArray);\r\n\r\n\t\t\treturn this.jsonStructure;\r\n\t\t},\r\n\r\n\t\tfindChildren: function(nodes) {\r\n\t\t\tvar parents = [0]; // start witha a root node\r\n\r\n\t\t\twhile(parents.length) {\r\n\t\t\t\tvar parentId = parents.pop(),\r\n\t\t\t\t\tparent = this.findNode(this.jsonStructure.nodeStructure, parentId),\r\n\t\t\t\t\ti = 0, len = nodes.length,\r\n\t\t\t\t\tchildren = [];\r\n\r\n\t\t\t\tfor(;i<len;i++) {\r\n\t\t\t\t\tvar node = nodes[i];\r\n\t\t\t\t\tif(node.parent && (node.parent.myID == parentId)) { // skip config and root nodes\r\n\r\n\t\t\t\t\t\tnode.myID = this.getID();\r\n\r\n\t\t\t\t\t\tdelete node.parent;\r\n\r\n\t\t\t\t\t\tchildren.push(node);\r\n\t\t\t\t\t\tparents.push(node.myID);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (children.length) {\r\n\t\t\t\t\tparent.children = children;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tfindNode: function(node, nodeId) {\r\n\t\t\tvar childrenLen, found;\r\n\r\n\t\t\tif (node.myID === nodeId) {\r\n\t\t\t\treturn node;\r\n\t\t\t} else if (node.children) {\r\n\t\t\t\tchildrenLen = node.children.length;\r\n\t\t\t\twhile(childrenLen--) {\r\n\t\t\t\t\tfound = this.findNode(node.children[childrenLen], nodeId);\r\n\t\t\t\t\tif(found) {\r\n\t\t\t\t\t\treturn found;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tgetID: (function() {\r\n\t\t\tvar i = 0;\r\n\t\t\treturn function() {\r\n\t\t\t\treturn i++;\r\n\t\t\t};\r\n\t\t})()\r\n\t};\r\n\r\n\t/**\r\n\t* Chart constructor.\r\n\t*/\r\n\tvar Treant = function(jsonConfig, callback) {\r\n\r\n\t\tif (jsonConfig instanceof Array) {\r\n\t\t\tjsonConfig = JSONconfig.make(jsonConfig);\r\n\t\t}\r\n\r\n\t\tvar newTree = TreeStore.createTree(jsonConfig);\r\n\t\tnewTree.positionTree(callback);\r\n\r\n\t\tthis.tree_id = newTree.id;\r\n\t};\r\n\r\n\tTreant.prototype.destroy = function() {\r\n\t\tTreeStore.destroy(this.tree_id);\r\n\t};\r\n\r\n\t/* expose constructor globaly */\r\n\texports.Treant = Treant;\r\n\r\n})( this.hasOwnProperty('window') ? window: module.exports );\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}